"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsTUFBTUMsVUFBVUMsU0FBU0YsMkNBQVFBLENBQUNHLE9BQU8sQ0FBQyxRQUFRO0FBR2hELENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanM/ZjE3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgXCJcIikpO1xuZXhwb3J0IHtcbiAgdmVyc2lvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSRVZJU0lPTiIsInZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = ()=>{\n    if (generated) return generated;\n    const wasm_base = \"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\";\n    const wasm_simd = \"B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB\";\n    const detector = new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        3,\n        2,\n        0,\n        0,\n        5,\n        3,\n        1,\n        0,\n        1,\n        12,\n        1,\n        0,\n        10,\n        22,\n        2,\n        12,\n        0,\n        65,\n        0,\n        65,\n        0,\n        65,\n        0,\n        252,\n        10,\n        0,\n        0,\n        11,\n        7,\n        0,\n        65,\n        0,\n        253,\n        15,\n        26,\n        11\n    ]);\n    const wasmpack = new Uint8Array([\n        32,\n        0,\n        65,\n        253,\n        3,\n        1,\n        2,\n        34,\n        4,\n        106,\n        6,\n        5,\n        11,\n        8,\n        7,\n        20,\n        13,\n        33,\n        12,\n        16,\n        128,\n        9,\n        116,\n        64,\n        19,\n        113,\n        127,\n        15,\n        10,\n        21,\n        22,\n        14,\n        255,\n        66,\n        24,\n        54,\n        136,\n        107,\n        18,\n        23,\n        192,\n        26,\n        114,\n        118,\n        132,\n        17,\n        77,\n        101,\n        130,\n        144,\n        27,\n        87,\n        131,\n        44,\n        45,\n        74,\n        156,\n        154,\n        70,\n        167\n    ]);\n    if (typeof WebAssembly !== \"object\") {\n        return {\n            supported: false\n        };\n    }\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n    }\n    let instance;\n    const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result)=>{\n        instance = result.instance;\n        instance.exports.__wasm_call_ctors();\n    });\n    function unpack(data) {\n        const result = new Uint8Array(data.length);\n        for(let i = 0; i < data.length; ++i){\n            const ch = data.charCodeAt(i);\n            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n        }\n        let write = 0;\n        for(let i = 0; i < data.length; ++i){\n            result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n        }\n        return result.buffer.slice(0, write);\n    }\n    function decode(fun, target, count, size, source, filter) {\n        const sbrk = instance.exports.sbrk;\n        const count4 = count + 3 & ~3;\n        const tp = sbrk(count4 * size);\n        const sp = sbrk(source.length);\n        const heap = new Uint8Array(instance.exports.memory.buffer);\n        heap.set(source, sp);\n        const res = fun(tp, count, size, sp, source.length);\n        if (res === 0 && filter) {\n            filter(tp, count4, size);\n        }\n        target.set(heap.subarray(tp, tp + count * size));\n        sbrk(tp - sbrk(0));\n        if (res !== 0) {\n            throw new Error(`Malformed buffer data: ${res}`);\n        }\n    }\n    const filters = {\n        // legacy index-based enums for glTF\n        0: \"\",\n        1: \"meshopt_decodeFilterOct\",\n        2: \"meshopt_decodeFilterQuat\",\n        3: \"meshopt_decodeFilterExp\",\n        // string-based enums for glTF\n        NONE: \"\",\n        OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n        QUATERNION: \"meshopt_decodeFilterQuat\",\n        EXPONENTIAL: \"meshopt_decodeFilterExp\"\n    };\n    const decoders = {\n        // legacy index-based enums for glTF\n        0: \"meshopt_decodeVertexBuffer\",\n        1: \"meshopt_decodeIndexBuffer\",\n        2: \"meshopt_decodeIndexSequence\",\n        // string-based enums for glTF\n        ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n        TRIANGLES: \"meshopt_decodeIndexBuffer\",\n        INDICES: \"meshopt_decodeIndexSequence\"\n    };\n    generated = {\n        ready: promise,\n        supported: true,\n        decodeVertexBuffer (target, count, size, source, filter) {\n            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n        },\n        decodeIndexBuffer (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n        },\n        decodeIndexSequence (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n        },\n        decodeGltfBuffer (target, count, size, source, mode, filter) {\n            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n        }\n    };\n    return generated;\n};\n //# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBO0FBQ0osTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUlELFdBQ0YsT0FBT0E7SUFDVCxNQUFNRSxZQUFZO0lBQ2xCLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTUMsV0FBVyxJQUFJRCxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsSUFBSSxPQUFPRSxnQkFBZ0IsVUFBVTtRQUNuQyxPQUFPO1lBQ0xDLFdBQVc7UUFDYjtJQUNGO0lBQ0EsSUFBSUMsT0FBT1A7SUFDWCxJQUFJSyxZQUFZRyxRQUFR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QUFrQjNCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU07WUFDM0NMLE9BQU9oQixTQUFTTSxPQUFPLENBQUN3Qyx5QkFBeUIsRUFBRTVCLFFBQVFDLE9BQU9DLE1BQU1DO1FBQzFFO1FBQ0EwQixxQkFBb0I3QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1lBQzdDTCxPQUFPaEIsU0FBU00sT0FBTyxDQUFDMEMsMkJBQTJCLEVBQUU5QixRQUFRQyxPQUFPQyxNQUFNQztRQUM1RTtRQUNBNEIsa0JBQWlCL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFNkIsSUFBSSxFQUFFNUIsTUFBTTtZQUN4RE4sT0FDRWhCLFNBQVNNLE9BQU8sQ0FBQ2dDLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDLEVBQ2hDaEMsUUFDQUMsT0FDQUMsTUFDQUMsUUFDQXJCLFNBQVNNLE9BQU8sQ0FBQzJCLE9BQU8sQ0FBQ1gsT0FBTyxDQUFDO1FBRXJDO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUdFLENBQ0YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanM/YTdmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZ2VuZXJhdGVkO1xuY29uc3QgTWVzaG9wdERlY29kZXIgPSAoKSA9PiB7XG4gIGlmIChnZW5lcmF0ZWQpXG4gICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgY29uc3Qgd2FzbV9iYXNlID0gXCJCOWg5ejl0RkJCQkY4Zkw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmE5Z0VhYWFGYUVNY0JGRkZHR0dFSUlJTEY5d0ZGRkxFRkJGS05GYUZDeC9JRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJGOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCR3k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCRW45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQklpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCS0k5ejlpcWxCT2MreDh5Y0dCTS9xUUZUYThqVVVVVUJDVS9FQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHVGtVVVVCUk5DVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSVkFFQ0ZKUklDQlJjR1hFWEFjQUY5UFFGQVZBRkFjbEFjQVZKQUY5SnlSTUdYR1hBRzlGUUJBTUNiSkhLQzl3WlJTQUtDSXJDRUpDR3JSUUFOQ1VHSlJmQ0JSYkFJUlRFWEdYQU9BVGxBUTlQUUJDQlJJU0VNQVRBUUpSSUdYQVM5RlFCQ0JSdENCUkVFWEdYQU9BSWxDaTlQUUJDQlJJU0xNQU5DVS9DQkpBRUpSS0dYR1hHWEdYR1hBVEFFQ0tySjJCQkF0Q0tackNFWmZJQkZHRUJNQUtoQjgzRUJBS0NOSmhCODNFQlNFTUFLQUkyQklBSTJCQkhtQ0tySFlBWUNFNkhZeTg2QkJBS0NGSkFJQ0lKQVlKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDR0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ0VKQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NJSkFZQW1KSFkyQkJBSTJCRkhtQ0tySFBBUENFNkhQeTg2QkJBS0NMSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDS0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ09KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NOSkFZQW1KSFkyQkJBSTJCR0htQ0tySFBBUENFNkhQeTg2QkJBS0NWSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDY0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ01KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NTSkFZQW1KSG0yQkJBSTJCRUhJQ0tySFlBWUNFNkhZeTg2QkJBS0NRSkFtQVlKSG0yQkJBSUNJckNFWkhZQVlDRTZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUlDR3JDRVpIWUFZQ0U2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ0VaSElBSUNFNkhJeTg2QkJBS0FJSlJJU0dNQUtBSTJCTkFJMkJCSG1DSXJIWUFZQ2I2SFl5ODZCQkFLQ0ZKQUlDTkpBWUpIWTJCQkFtQ2JaSG1BbUNiNkhteTg2QkJBS0NHSkFZQW1KSG0yQkJBSTJCRkhZQ0lySFBBUENiNkhQeTg2QkJBS0NFSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDSUpBbUFZSkhtMkJCQUkyQkdIWUNJckhQQVBDYjZIUHk4NkJCQUtDTEpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0tKQW1BWUpIbTJCQkFJMkJFSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ09KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NOSkFtQVlKSG0yQkJBSTJCSUhZQ0lySFBBUENiNkhQeTg2QkJBS0NWSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDY0pBbUFZSkhtMkJCQUkyQkxIWUNJckhQQVBDYjZIUHk4NkJCQUtDTUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ1NKQW1BWUpIbTJCQkFJMkJLSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1FKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSTJCT0hJQ0lySFlBWUNiNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNiWkhJQUlDYjZISXk4NkJCQUtBSUpSSVNGTUFLQUk4cEJCODNCQkFLQ05KQUlDTko4cEJCODNCQkFJQ1RKUklNQXRDR0pSdEFFQ1RKSEVBUzlKUUJNTUdYQUlRQkNCUklTRU1HWEFNOUZRQkFOQWJKMkJCUnRDQlJLQWZSRUVYQUVBTkNVL0NCSkFLSjJCQkhUQ0ZyQ0JBVENGWmw5ekF0Skh0ODZCQkFFQUdKUkVBS0NGSkhLQU05SFFCTU1BZkNGSlJmQUlSVEFiQ0ZKSGJBRzlIUUJNTUFCQWNBRzlzSkFOQ1VHSkFNQUc5c1RrVVVVQnBBTkFOQ1VHSkFNQ2FKQUc5c0pBR1RrVVVVQnBNQU1DQkFJeUFjSlJjQUlRQk1DOStSS1NGTUNCQzk5QU9BSWxBR0NBQUdDQTlMeTZ5UktNQUxDVS9FQko4a1VVVVVCQUtNK09tRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGVCtKVVVVQnBBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNK2xMS0ZhRjk5R2FHOTlGYUc5OUdYR1hBR0NJOUhRQkFGOUZRRkVYR1hHWDlEQkJCOC85REJCQisvQUJDR0pIRzFCQit5QUIxQkJIRSt5SEkrTCtUQUJDRkpITDFCQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REJCLytoQU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg2QkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg2QkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg2QkJBQkNJSlJCQUZDYUpIRlFCU0dNTUFGOUZRQkVYR1hHWDlEQkJCOC85REJCQisvQUJDSUpIRzh1RkIreUFCOHVGQkhFK3lISStMK1RBQkNHSkhMOHVGQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REIvK2c2QU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg3RkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg3RkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg3RkJBQkNOSlJCQUZDYUpIRlFCTU1NL1NFSUVhRTk5RWFGOTlHWEFGOUZRQkNCUkVBQlJJRVhHWEdYOUQvekk4MTgvQUlDS0o4dUZCSExDRXEreStWSEtBSTh1RkIreStVSE85REIvK2c2K1U5REJCQjgvOURCQkIrL0FPOURCQkJCOWd5K1NITitMOURCQkI5UDlkOUZRQkFOK29SVlNGTUNVVVVVOTRSVk1BSUNJSjh1RkJSY0FJQ0dKOHVGQlJNQUJBTENGSkNFWkFFcUNGV0pBVjg3RkJHWEdYQUtBTSt5K1VITjlEQi8rZzYrVTlEQkJCOC85REJCQisvQU45REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JNU0ZNQ1VVVVU5NFJNTUFCQUxDR0pDRVpBRXFDRldKQU04N0ZCR1hHWEFLQWMreStVSEs5REIvK2c2K1U5REJCQjgvOURCQkIrL0FLOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29SY1NGTUNVVVVVOTRSY01BQkFMQ2FKQ0VaQUVxQ0ZXSkFjODdGQkdYR1g5REJCVTgvQU9BTytVK1RBTkFOK1UrVEFLQUsrVStUSE85REJCQkJBTzlEQkJCQjlneStSOURCLytnNitVOURCQkI4LytTSE8rTDlEQkJCOVA5ZDlGUUJBTytvUmNTRk1DVVVVVTk0UmNNQUJBTENFWkFFcUNGV0pBYzg3RkJBSUNOSlJJQUVDSUpSRUFGQ2FKSEZRQk1NTTlKQkdYQUdDR3JBRjlzSEY5RlFCRVhBQkFCOG9HQkhHQ05XQ045MSt5QUdDaTkxQ25XQ1VVVS84RUorKytVODRHQkFCQ0lKUkJBRkNhSkhGUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNL2xGRkZhR1hHWEFGQUJxQ0VaOUZRQkFCUkVTRk1HWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBRjhvR0JqR0JBRUNJSkFGQ0lKOG9HQmpHQkFFQ05KQUZDTko4b0dCakdCQUVDU0pBRkNTSjhvR0JqR0JBRUNUSlJFQUZDVEpSRkFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBRjhvR0JqR0JBRkNJSlJGQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjJCQjg2QkJBRUNGSlJFQUZDRkpSRkFHQ2FKSEdRQk1NQUJNb0ZGR2FHWEdYQUJDRVo5RlFCQUJSRVNGTUFGQ2dGWkMrQndzTjlzUklHWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBSWpHQkFFQ1NKQUlqR0JBRUNOSkFJakdCQUVDSUpBSWpHQkFFQ1RKUkVBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUlqR0JBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGODZCQkFFQ0ZKUkVBR0NhSkhHUUJNTUFCTU1NRkJDVU5NSVQ5a0JCXCI7XG4gIGNvbnN0IHdhc21fc2ltZCA9IFwiQjloOXo5dEZCQkJGaUk5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmFFTWNCQkZCRkZHR0dFSUxGOXdGRkZMRUZCRktORmFGQ3gvYUZNTy9MRlZLOXR2OXQ5dnE5NUdCdDlmOWY5MzloOXo5dDlmOWo5aDlzOXM5ZjlqVzl2cTl6QkJwOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OVd2cVd2OTRoOTE5bTltdnFCRzhaOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0aDkxOW05bXZxQkl5OXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0OVR2Wjkxdjl1OWp2QkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UDlqV0JLaTl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVI5MTloV0JPbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOUY5NDl3Qk5JOXo5aXFsQlZjK045SWNJQlRFTTkrRkxhOGpVVVVVQkNUbFJCQ0JSRkVYQ0JSR0NCUkVFWEFCQ05KQUdKQUVDVWFBRkFHckNGWkhJeTg2QkJBRUFJSlJFQUdDRkpIR0NOOUhRQk1BRkN4K1lVVUJKQUU4NkJCQUZDRVdDeGtVVUJKQUI4cEVOODNFQkFGQ0ZKSEZDVUc5SFFCTU1rOGxMYmFFOTdGOStGYUw5NzhqVVVVVUJDVS9LQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHLzhjQkJDVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSTkFFQ0ZKUktDQlJWR1hFWEFWQUY5UFFGQU5BRkFWbEFWQU5KQUY5SnlSY0dYR1hBRzlGUUJBY0NiSkhJQzl3WkhNQ0U5c1JTQU1DRldSUUFJQ0lyQ0VKQ0dyUmZDQlJiRVhBS1JUQ0JSdEdYRVhHWEFPQVRsQWY5UFFCQ0JSS1NMTUFMQ1UvQ0JKQXRBTTlzSlJtQVRBZkpSS0NCUkVHWEFNQ29COUpRQkFPQUtsQy9nQjlKUUJDQlJJRVhBbUFJSlJFR1hHWEdYR1hHWEFUQUlDS3JKMkJCSFlDRVpmSUJGR0VCTUFFQ0JEdERNSUJTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlCQUtDVEpSS01HWEdYR1hHWEdYQVlDR3JDRVpmSUJGR0VCTUFFQ0JEdERNSVRTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlUQUtDVEpSS01HWEdYR1hHWEdYQVlDSXJDRVpmSUJGR0VCTUFFQ0JEdERNSUFTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlBQUtDVEpSS01HWEdYR1hHWEdYQVlDS3JmSUJGR0VCTUFFQ0JEdERNSTh3U0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NJSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDTkpBZURlQkpBWUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUk4d0FLQ1RKUktNQUlDb0JKUkVBSUNVRkpBTTlMUUZBRVJJQU9BS2xDL2ZCOUxRQk1NR1hBRUFNOVBRQkFFQ0VyUklFWEdYQU9BS2xDaTlQUUJDQlJLU09NQW1BRUpSWUdYR1hHWEdYR1hBVEFFQ0tySjJCQkFJQ0tackNFWmZJQkZHRUJNQVlDQkR0RE1JQlNFTUFZQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BWUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BWUFLREJCQkRNSUJBS0NUSlJLTUFJQ0dKUklBRUNUSkhFQU05SlFCTU1HWEFLOUZRQkFLUlRBdENGSkh0Q0k2UUdTRk1NQ0JSS1NFTUdYQU05RlFCQUxDVUdKQWJKUkVBTEFiSkRCR0JSZUNCUllFWEFFQUxDVS9DQkpBWUpISURCSUJIZENGRDl0QWRDRkRiSFBEOU9EOWhEOVJIZEFJQU1KREJJQkg4WkNGRDl0QThaQVBEOU9EOWhEOVJIOFpEUUJURnRHbUVZSVBMZEtlT25IcEFJQVFKREJJQkh5Q0ZEOXRBeUFQRDlPRDloRDlSSHlBSUFTSkRCSUJIOGNDRkQ5dEE4Y0FQRDlPRDloRDlSSDhjRFFCVEZ0R21FWUlQTGRLZU9uSDhkRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUFlRDl1SGVEeUJqR0JBRUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBcEE4ZERRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4ZkhkQXlBOGNEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4Zkg4WkRRQkZUdEdFbVlJTFBkS09lbkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFkQThaRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSlJFQVlDVEpIWUFNOUpRQk1NQWJDSUpIYkFHOUpRQk1NQUJBVkFHOXNKQUxDVUdKQWNBRzlzLzhjQkJBTEFMQ1VHSkFjQ2FKQUc5c0pBRy84Y0JCTUFjQ0JBS3lBVkpSVkFLUUJNQzkrUktTRk1DQkM5OUFPQUtsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvS0JKOGtVVVVVQkFLTU5CVCtCVVVVQk0rS21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUYvOE1CQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTS9kTEVLOTdGYUY5N0dYR1hBR0NJOUhRQkFGOUZRRkNCUkdFWEFCQUJEQkJCSEVDaUQrckZDaUQrc0ZELzZGSElBRUNORCtyRkNpRCtzRkQvNkZBSUQvZ0ZBRUNURCtyRkNpRCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhLQ0JEdEQrMkZIT0FJQ1VVVVU5NER0SE5EOU9EOVJEL2tGSEk5REJCLytoRFlBSUFJRC9tRkFLQUtEL21GQUxBT0FMQU5EOU9EOVJEL2tGSElBSUQvbUZEL2tGRC9rRkQvakZEL25GSExEL21GOURCQlg5TERZSE9EL2tGQ2dGRHREOU9BRUNVVVU5NER0RDlPRDlRQUlBTEQvbUZBT0Qva0ZDTkQrckZDVS8rRUR0RDlPRDlRQUtBTEQvbUZBT0Qva0ZDVEQrckZDVVUvOE9EdEQ5T0Q5UURNQkJBQkNUSlJCQUdDSUpIR0FGOUpRQlNHTU1BRjlGUUJDQlJHRVhBQkNUSkhWQVZEQkJCSEVDQkR0SE9DVVU5OEQ4Y0ZDVVU5OEQ4Y0VITkQ5T0FCREJCQkhLQUVEUUlMS09TUWZiUGRlbjhjOGQ4ZThmQ2dnRkR0RDlPRC82RkFLQUVEUUJGR0VOVmNNVHRtWWk4WnB5SEVDVEQrc0ZELzZGSElEL2dGQUVDVEQrckZDVEQrc0ZELzZGSExEL2dGRC9rRkQvbEZIRTlEQi8rZzZEWUFMQUVBT0QrMkZIT0FMQ1VVVVU5NER0SGNEOU9EOVJEL2tGSExBTEQvbUZBRUFFRC9tRkFJQU9BSUFjRDlPRDlSRC9rRkhFQUVEL21GRC9rRkQva0ZEL2pGRC9uRkhJRC9tRjlEQkJYOUxEWUhPRC9rRkNURCtyRkFMQUlEL21GQU9EL2tGQ2dnRUR0RDlPRDlRSExBRUFJRC9tRkFPRC9rRkNhRGJDQkRuR0NCRG5FQ0JEbktDQkRuT0NCRG5jQ0JEbk1DQkRuZkNCRG5iRDlPSEVEUU5WaThaY01weVNROGM4ZGZiOGU4ZkQ5UURNQkJBQkFLQU5EOU9BTEFFRFFCRlR0R0VtWUlMUGRLT2VuRDlRRE1CQkFCQ0FKUkJBR0NJSkhHQUY5SlFCTU1NL2hFSUdhRjk3RmFMOTc4alVVVVVCQ1RsUkVHWEFGOUZRQkNCUklFWEFFQUJEQkJCSExBQkNUSkhLREJCQkhPRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkhOQ1REK3NGSFZDSUQrckZETUlCQUI5REJCVTgvRFk5RC96STgxOC9EWUFWQ0VEdEQ5UUQvNkZEL25GSFZBTEFPRFFCRkdFTlZjTVR0bVlpOFpweUhMQ1REK3JGQ1REK3NGRC82RkQvbUZIT0FPRC9tRkFWQUxDVEQrc0ZELzZGRC9tRkhjQWNEL21GQVZBTkNURCtyRkNURCtzRkQvNkZEL21GSE5BTkQvbUZEL2tGRC9rRkQvbEZDQkR0RCs0RkQvakY5REIvK2c2RFlIVkQvbUY5REJCWDlMRFlITEQva0ZDZ2dFRHRITUQ5T0FjQVZEL21GQUxEL2tGQ1REK3JGRDlRSGNBTkFWRC9tRkFMRC9rRkNURCtyRkFPQVZEL21GQUxEL2tGQU1EOU9EOVFIVkRRQkZUdEdFbVlJTFBkS09lbkhMRDhkQkFFREJJQkR5Qit0K0o4M0VCQUJDTkpBTEQ4ZEZBRURCSUJEeUYrdCtKODNFQkFLQWNBVkRRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFZEOGRCQUVEQklCRHlHK3QrSjgzRUJBQkNpSkFWRDhkRkFFREJJQkR5RSt0K0o4M0VCQUJDQUpSQkFJQ0lKSElBRjlKUUJNTU05akZGOTdHWEFHQ0dyQUY5c0hHOUZRQkNCUkZFWEFCQUJEQkJCSEVDTkQrckZDTkQrc0ZELzZGQUVDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNQkJBQkNUSlJCQUZDSUpIRkFHOUpRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU1NTUZCQ1VOTUlUOXRCQlwiO1xuICBjb25zdCBkZXRlY3RvciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLFxuICAgIDk3LFxuICAgIDExNSxcbiAgICAxMDksXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxLFxuICAgIDQsXG4gICAgMSxcbiAgICA5NixcbiAgICAwLFxuICAgIDAsXG4gICAgMyxcbiAgICAzLFxuICAgIDIsXG4gICAgMCxcbiAgICAwLFxuICAgIDUsXG4gICAgMyxcbiAgICAxLFxuICAgIDAsXG4gICAgMSxcbiAgICAxMixcbiAgICAxLFxuICAgIDAsXG4gICAgMTAsXG4gICAgMjIsXG4gICAgMixcbiAgICAxMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDI1MixcbiAgICAxMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMTEsXG4gICAgNyxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUzLFxuICAgIDE1LFxuICAgIDI2LFxuICAgIDExXG4gIF0pO1xuICBjb25zdCB3YXNtcGFjayA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAzMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDI1MyxcbiAgICAzLFxuICAgIDEsXG4gICAgMixcbiAgICAzNCxcbiAgICA0LFxuICAgIDEwNixcbiAgICA2LFxuICAgIDUsXG4gICAgMTEsXG4gICAgOCxcbiAgICA3LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDMzLFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEyOCxcbiAgICA5LFxuICAgIDExNixcbiAgICA2NCxcbiAgICAxOSxcbiAgICAxMTMsXG4gICAgMTI3LFxuICAgIDE1LFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDIyLFxuICAgIDE0LFxuICAgIDI1NSxcbiAgICA2NixcbiAgICAyNCxcbiAgICA1NCxcbiAgICAxMzYsXG4gICAgMTA3LFxuICAgIDE4LFxuICAgIDIzLFxuICAgIDE5MixcbiAgICAyNixcbiAgICAxMTQsXG4gICAgMTE4LFxuICAgIDEzMixcbiAgICAxNyxcbiAgICA3NyxcbiAgICAxMDEsXG4gICAgMTMwLFxuICAgIDE0NCxcbiAgICAyNyxcbiAgICA4NyxcbiAgICAxMzEsXG4gICAgNDQsXG4gICAgNDUsXG4gICAgNzQsXG4gICAgMTU2LFxuICAgIDE1NCxcbiAgICA3MCxcbiAgICAxNjdcbiAgXSk7XG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgbGV0IHdhc20gPSB3YXNtX2Jhc2U7XG4gIGlmIChXZWJBc3NlbWJseS52YWxpZGF0ZShkZXRlY3RvcikpIHtcbiAgICB3YXNtID0gd2FzbV9zaW1kO1xuICB9XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgcHJvbWlzZSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHVucGFjayh3YXNtKSwge30pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGluc3RhbmNlID0gcmVzdWx0Lmluc3RhbmNlO1xuICAgIGluc3RhbmNlLmV4cG9ydHMuX193YXNtX2NhbGxfY3RvcnMoKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVucGFjayhkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICByZXN1bHRbaV0gPSBjaCA+IDk2ID8gY2ggLSA3MSA6IGNoID4gNjQgPyBjaCAtIDY1IDogY2ggPiA0NyA/IGNoICsgNCA6IGNoID4gNDYgPyA2MyA6IDYyO1xuICAgIH1cbiAgICBsZXQgd3JpdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W3dyaXRlKytdID0gcmVzdWx0W2ldIDwgNjAgPyB3YXNtcGFja1tyZXN1bHRbaV1dIDogKHJlc3VsdFtpXSAtIDYwKSAqIDY0ICsgcmVzdWx0WysraV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyLnNsaWNlKDAsIHdyaXRlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoZnVuLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgIGNvbnN0IHNicmsgPSBpbnN0YW5jZS5leHBvcnRzLnNicms7XG4gICAgY29uc3QgY291bnQ0ID0gY291bnQgKyAzICYgfjM7XG4gICAgY29uc3QgdHAgPSBzYnJrKGNvdW50NCAqIHNpemUpO1xuICAgIGNvbnN0IHNwID0gc2Jyayhzb3VyY2UubGVuZ3RoKTtcbiAgICBjb25zdCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICBoZWFwLnNldChzb3VyY2UsIHNwKTtcbiAgICBjb25zdCByZXMgPSBmdW4odHAsIGNvdW50LCBzaXplLCBzcCwgc291cmNlLmxlbmd0aCk7XG4gICAgaWYgKHJlcyA9PT0gMCAmJiBmaWx0ZXIpIHtcbiAgICAgIGZpbHRlcih0cCwgY291bnQ0LCBzaXplKTtcbiAgICB9XG4gICAgdGFyZ2V0LnNldChoZWFwLnN1YmFycmF5KHRwLCB0cCArIGNvdW50ICogc2l6ZSkpO1xuICAgIHNicmsodHAgLSBzYnJrKDApKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBidWZmZXIgZGF0YTogJHtyZXN9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbHRlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgMjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICAzOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgTk9ORTogXCJcIixcbiAgICBPQ1RBSEVEUkFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgUVVBVEVSTklPTjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICBFWFBPTkVOVElBTDogXCJtZXNob3B0X2RlY29kZUZpbHRlckV4cFwiXG4gIH07XG4gIGNvbnN0IGRlY29kZXJzID0ge1xuICAgIC8vIGxlZ2FjeSBpbmRleC1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIDA6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXJcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZVwiLFxuICAgIC8vIHN0cmluZy1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIEFUVFJJQlVURVM6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICBUUklBTkdMRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIElORElDRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCJcbiAgfTtcbiAgZ2VuZXJhdGVkID0ge1xuICAgIHJlYWR5OiBwcm9taXNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBkZWNvZGVWZXJ0ZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICAgIGRlY29kZShcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgICAgIGRlY29kZShpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleFNlcXVlbmNlKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgZGVjb2RlR2x0ZkJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIG1vZGUsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2RlY29kZXJzW21vZGVdXSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZ2VuZXJhdGVkO1xufTtcbmV4cG9ydCB7XG4gIE1lc2hvcHREZWNvZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaG9wdERlY29kZXIuanMubWFwXG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVkIiwiTWVzaG9wdERlY29kZXIiLCJ3YXNtX2Jhc2UiLCJ3YXNtX3NpbWQiLCJkZXRlY3RvciIsIlVpbnQ4QXJyYXkiLCJ3YXNtcGFjayIsIldlYkFzc2VtYmx5Iiwic3VwcG9ydGVkIiwid2FzbSIsInZhbGlkYXRlIiwiaW5zdGFuY2UiLCJwcm9taXNlIiwiaW5zdGFudGlhdGUiLCJ1bnBhY2siLCJ0aGVuIiwicmVzdWx0IiwiZXhwb3J0cyIsIl9fd2FzbV9jYWxsX2N0b3JzIiwiZGF0YSIsImxlbmd0aCIsImkiLCJjaCIsImNoYXJDb2RlQXQiLCJ3cml0ZSIsImJ1ZmZlciIsInNsaWNlIiwiZGVjb2RlIiwiZnVuIiwidGFyZ2V0IiwiY291bnQiLCJzaXplIiwic291cmNlIiwiZmlsdGVyIiwic2JyayIsImNvdW50NCIsInRwIiwic3AiLCJoZWFwIiwibWVtb3J5Iiwic2V0IiwicmVzIiwic3ViYXJyYXkiLCJFcnJvciIsImZpbHRlcnMiLCJOT05FIiwiT0NUQUhFRFJBTCIsIlFVQVRFUk5JT04iLCJFWFBPTkVOVElBTCIsImRlY29kZXJzIiwiQVRUUklCVVRFUyIsIlRSSUFOR0xFUyIsIklORElDRVMiLCJyZWFkeSIsImRlY29kZVZlcnRleEJ1ZmZlciIsIm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyIiwiZGVjb2RlSW5kZXhCdWZmZXIiLCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyIiwiZGVjb2RlSW5kZXhTZXF1ZW5jZSIsIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZSIsImRlY29kZUdsdGZCdWZmZXIiLCJtb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            const taskConfig = {\n                attributeIDs: this.defaultAttributeIDs,\n                attributeTypes: this.defaultAttributeTypes,\n                useUniqueIDs: false\n            };\n            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n        }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs\n        };\n        this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        for(const attribute in taskConfig.attributeTypes){\n            const type = taskConfig.attributeTypes[attribute];\n            if (type.BYTES_PER_ELEMENT !== void 0) {\n                taskConfig.attributeTypes[attribute] = type.name;\n            }\n        }\n        const taskKey = JSON.stringify(taskConfig);\n        if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            if (cachedTask.key === taskKey) {\n                return cachedTask.promise;\n            } else if (buffer.byteLength === 0) {\n                throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n            }\n        }\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve,\n                    reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig,\n                    buffer\n                }, [\n                    buffer\n                ]);\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) {\n                this._releaseTask(worker, taskID);\n            }\n        });\n        _taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometryData.index) {\n            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n        }\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const attribute = geometryData.attributes[i];\n            const name = attribute.name;\n            const array = attribute.array;\n            const itemSize = attribute.itemSize;\n            geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n        }\n        return geometry;\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, void 0, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) {\n            librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        } else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) {\n                this.decoderConfig.wasmBinary = libraries[1];\n            }\n            const fn = DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker2 = new Worker(this.workerSourceURL);\n                worker2._callbacks = {};\n                worker2._taskCosts = {};\n                worker2._taskLoad = 0;\n                worker2.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker2.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker2._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker2._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker2);\n            } else {\n                this.workerPool.sort(function(a, b) {\n                    return a._taskLoad > b._taskLoad ? -1 : 1;\n                });\n            }\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i){\n            this.workerPool[i].terminate();\n        }\n        this.workerPool.length = 0;\n        return this;\n    }\n}\nfunction DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        resolve({\n                            draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    const decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n        } else {\n            throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        }\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n            throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        }\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n        }\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        }\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n //# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUUsTUFBTUksYUFBYSxhQUFhLEdBQUcsSUFBSUM7QUFDdkMsTUFBTUMsb0JBQW9CTix5Q0FBTUE7SUFDOUJPLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUN6QkMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztZQUMzQkosVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO0lBQ0Y7SUFDQUUsZUFBZUMsSUFBSSxFQUFFO1FBQ25CLElBQUksQ0FBQ2YsV0FBVyxHQUFHZTtRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUJDLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUNoQixhQUFhLEdBQUdnQjtRQUNyQixPQUFPLElBQUk7SUFDYjtJQUNBQyxlQUFlZCxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0FlLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxNQUFNQyxTQUFTLElBQUloQyw2Q0FBVUEsQ0FBQyxJ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QUtDO2dCQUNILE9BQU94RCxNQUFNeUQsUUFBUTtZQUN2QixLQUFLQztnQkFDSCxPQUFPMUQsTUFBTTJELFFBQVE7WUFDdkIsS0FBS0M7Z0JBQ0gsT0FBTzVELE1BQU02RCxTQUFTO1lBQ3hCLEtBQUt0QjtnQkFDSCxPQUFPdkMsTUFBTThELFNBQVM7UUFDMUI7SUFDRjtBQUNGO0FBR0UsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9EUkFDT0xvYWRlci5qcz83NGY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgRmlsZUxvYWRlciwgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgX3Rhc2tDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgRFJBQ09Mb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IFwiXCI7XG4gICAgdGhpcy5kZWNvZGVyQ29uZmlnID0ge307XG4gICAgdGhpcy5kZWNvZGVyQmluYXJ5ID0gbnVsbDtcbiAgICB0aGlzLmRlY29kZXJQZW5kaW5nID0gbnVsbDtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gNDtcbiAgICB0aGlzLndvcmtlclBvb2wgPSBbXTtcbiAgICB0aGlzLndvcmtlck5leHRUYXNrSUQgPSAxO1xuICAgIHRoaXMud29ya2VyU291cmNlVVJMID0gXCJcIjtcbiAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMgPSB7XG4gICAgICBwb3NpdGlvbjogXCJQT1NJVElPTlwiLFxuICAgICAgbm9ybWFsOiBcIk5PUk1BTFwiLFxuICAgICAgY29sb3I6IFwiQ09MT1JcIixcbiAgICAgIHV2OiBcIlRFWF9DT09SRFwiXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgbm9ybWFsOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgY29sb3I6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICB1djogXCJGbG9hdDMyQXJyYXlcIlxuICAgIH07XG4gIH1cbiAgc2V0RGVjb2RlclBhdGgocGF0aCkge1xuICAgIHRoaXMuZGVjb2RlclBhdGggPSBwYXRoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldERlY29kZXJDb25maWcoY29uZmlnKSB7XG4gICAgdGhpcy5kZWNvZGVyQ29uZmlnID0gY29uZmlnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFdvcmtlckxpbWl0KHdvcmtlckxpbWl0KSB7XG4gICAgdGhpcy53b3JrZXJMaW1pdCA9IHdvcmtlckxpbWl0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICAoYnVmZmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICAgICAgYXR0cmlidXRlSURzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICAgICAgYXR0cmlidXRlVHlwZXM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzLFxuICAgICAgICAgIHVzZVVuaXF1ZUlEczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpLnRoZW4ob25Mb2FkKS5jYXRjaChvbkVycm9yKTtcbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25FcnJvclxuICAgICk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIEtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyBEUkFDT0xvYWRlciB2ZXJzaW9ucy4gKi9cbiAgZGVjb2RlRHJhY29GaWxlKGJ1ZmZlciwgY2FsbGJhY2ssIGF0dHJpYnV0ZUlEcywgYXR0cmlidXRlVHlwZXMpIHtcbiAgICBjb25zdCB0YXNrQ29uZmlnID0ge1xuICAgICAgYXR0cmlidXRlSURzOiBhdHRyaWJ1dGVJRHMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuICAgICAgYXR0cmlidXRlVHlwZXM6IGF0dHJpYnV0ZVR5cGVzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzLFxuICAgICAgdXNlVW5pcXVlSURzOiAhIWF0dHJpYnV0ZUlEc1xuICAgIH07XG4gICAgdGhpcy5kZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIGRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykge1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZV07XG4gICAgICBpZiAodHlwZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXSA9IHR5cGUubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFza0tleSA9IEpTT04uc3RyaW5naWZ5KHRhc2tDb25maWcpO1xuICAgIGlmIChfdGFza0NhY2hlLmhhcyhidWZmZXIpKSB7XG4gICAgICBjb25zdCBjYWNoZWRUYXNrID0gX3Rhc2tDYWNoZS5nZXQoYnVmZmVyKTtcbiAgICAgIGlmIChjYWNoZWRUYXNrLmtleSA9PT0gdGFza0tleSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkVGFzay5wcm9taXNlO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5EUkFDT0xvYWRlcjogVW5hYmxlIHRvIHJlLWRlY29kZSBhIGJ1ZmZlciB3aXRoIGRpZmZlcmVudCBzZXR0aW5ncy4gQnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gdHJhbnNmZXJyZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdvcmtlcjtcbiAgICBjb25zdCB0YXNrSUQgPSB0aGlzLndvcmtlck5leHRUYXNrSUQrKztcbiAgICBjb25zdCB0YXNrQ29zdCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGdlb21ldHJ5UGVuZGluZyA9IHRoaXMuX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KS50aGVuKChfd29ya2VyKSA9PiB7XG4gICAgICB3b3JrZXIgPSBfd29ya2VyO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd29ya2VyLl9jYWxsYmFja3NbdGFza0lEXSA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZGVjb2RlXCIsIGlkOiB0YXNrSUQsIHRhc2tDb25maWcsIGJ1ZmZlciB9LCBbYnVmZmVyXSk7XG4gICAgICB9KTtcbiAgICB9KS50aGVuKChtZXNzYWdlKSA9PiB0aGlzLl9jcmVhdGVHZW9tZXRyeShtZXNzYWdlLmdlb21ldHJ5KSk7XG4gICAgZ2VvbWV0cnlQZW5kaW5nLmNhdGNoKCgpID0+IHRydWUpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHdvcmtlciAmJiB0YXNrSUQpIHtcbiAgICAgICAgdGhpcy5fcmVsZWFzZVRhc2sod29ya2VyLCB0YXNrSUQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90YXNrQ2FjaGUuc2V0KGJ1ZmZlciwge1xuICAgICAga2V5OiB0YXNrS2V5LFxuICAgICAgcHJvbWlzZTogZ2VvbWV0cnlQZW5kaW5nXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5UGVuZGluZztcbiAgfVxuICBfY3JlYXRlR2VvbWV0cnkoZ2VvbWV0cnlEYXRhKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnlEYXRhLmluZGV4KSB7XG4gICAgICBnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKGdlb21ldHJ5RGF0YS5pbmRleC5hcnJheSwgMSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeURhdGEuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgIGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIF9sb2FkTGlicmFyeSh1cmwsIHJlc3BvbnNlVHlwZSkge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5kZWNvZGVyUGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShyZXNwb25zZVR5cGUpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsb2FkZXIubG9hZCh1cmwsIHJlc29sdmUsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBwcmVsb2FkKCkge1xuICAgIHRoaXMuX2luaXREZWNvZGVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2luaXREZWNvZGVyKCkge1xuICAgIGlmICh0aGlzLmRlY29kZXJQZW5kaW5nKVxuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gICAgY29uc3QgdXNlSlMgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIgfHwgdGhpcy5kZWNvZGVyQ29uZmlnLnR5cGUgPT09IFwianNcIjtcbiAgICBjb25zdCBsaWJyYXJpZXNQZW5kaW5nID0gW107XG4gICAgaWYgKHVzZUpTKSB7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX3dhc21fd3JhcHBlci5qc1wiLCBcInRleHRcIikpO1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fZGVjb2Rlci53YXNtXCIsIFwiYXJyYXlidWZmZXJcIikpO1xuICAgIH1cbiAgICB0aGlzLmRlY29kZXJQZW5kaW5nID0gUHJvbWlzZS5hbGwobGlicmFyaWVzUGVuZGluZykudGhlbigobGlicmFyaWVzKSA9PiB7XG4gICAgICBjb25zdCBqc0NvbnRlbnQgPSBsaWJyYXJpZXNbMF07XG4gICAgICBpZiAoIXVzZUpTKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlckNvbmZpZy53YXNtQmluYXJ5ID0gbGlicmFyaWVzWzFdO1xuICAgICAgfVxuICAgICAgY29uc3QgZm4gPSBEUkFDT1dvcmtlci50b1N0cmluZygpO1xuICAgICAgY29uc3QgYm9keSA9IFtcbiAgICAgICAgXCIvKiBkcmFjbyBkZWNvZGVyICovXCIsXG4gICAgICAgIGpzQ29udGVudCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCIvKiB3b3JrZXIgKi9cIixcbiAgICAgICAgZm4uc3Vic3RyaW5nKGZuLmluZGV4T2YoXCJ7XCIpICsgMSwgZm4ubGFzdEluZGV4T2YoXCJ9XCIpKVxuICAgICAgXS5qb2luKFwiXFxuXCIpO1xuICAgICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuICB9XG4gIF9nZXRXb3JrZXIodGFza0lELCB0YXNrQ29zdCkge1xuICAgIHJldHVybiB0aGlzLl9pbml0RGVjb2RlcigpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud29ya2VyUG9vbC5sZW5ndGggPCB0aGlzLndvcmtlckxpbWl0KSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcjIgPSBuZXcgV29ya2VyKHRoaXMud29ya2VyU291cmNlVVJMKTtcbiAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tDb3N0cyA9IHt9O1xuICAgICAgICB3b3JrZXIyLl90YXNrTG9hZCA9IDA7XG4gICAgICAgIHdvcmtlcjIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImluaXRcIiwgZGVjb2RlckNvbmZpZzogdGhpcy5kZWNvZGVyQ29uZmlnIH0pO1xuICAgICAgICB3b3JrZXIyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVjb2RlXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3NbbWVzc2FnZS5pZF0ucmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIG1lc3NhZ2UsIFwiJyArIG1lc3NhZ2UudHlwZSArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sLnB1c2god29ya2VyMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmtlclBvb2wuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuX3Rhc2tMb2FkID4gYi5fdGFza0xvYWQgPyAtMSA6IDE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJQb29sW3RoaXMud29ya2VyUG9vbC5sZW5ndGggLSAxXTtcbiAgICAgIHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF0gPSB0YXNrQ29zdDtcbiAgICAgIHdvcmtlci5fdGFza0xvYWQgKz0gdGFza0Nvc3Q7XG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0pO1xuICB9XG4gIF9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCkge1xuICAgIHdvcmtlci5fdGFza0xvYWQgLT0gd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXTtcbiAgICBkZWxldGUgd29ya2VyLl9jYWxsYmFja3NbdGFza0lEXTtcbiAgICBkZWxldGUgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXTtcbiAgfVxuICBkZWJ1ZygpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiVGFzayBsb2FkOiBcIixcbiAgICAgIHRoaXMud29ya2VyUG9vbC5tYXAoKHdvcmtlcikgPT4gd29ya2VyLl90YXNrTG9hZClcbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndvcmtlclBvb2wubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMud29ya2VyUG9vbFtpXS50ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgdGhpcy53b3JrZXJQb29sLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIERSQUNPV29ya2VyKCkge1xuICBsZXQgZGVjb2RlckNvbmZpZztcbiAgbGV0IGRlY29kZXJQZW5kaW5nO1xuICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSBcImluaXRcIjpcbiAgICAgICAgZGVjb2RlckNvbmZpZyA9IG1lc3NhZ2UuZGVjb2RlckNvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgZGVjb2RlckNvbmZpZy5vbk1vZHVsZUxvYWRlZCA9IGZ1bmN0aW9uKGRyYWNvKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgZHJhY28gfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBEcmFjb0RlY29kZXJNb2R1bGUoZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbWVzc2FnZS5idWZmZXI7XG4gICAgICAgIGNvbnN0IHRhc2tDb25maWcgPSBtZXNzYWdlLnRhc2tDb25maWc7XG4gICAgICAgIGRlY29kZXJQZW5kaW5nLnRoZW4oKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRyYWNvID0gbW9kdWxlLmRyYWNvO1xuICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgZHJhY28uRGVjb2RlcigpO1xuICAgICAgICAgIGNvbnN0IGRlY29kZXJCdWZmZXIgPSBuZXcgZHJhY28uRGVjb2RlckJ1ZmZlcigpO1xuICAgICAgICAgIGRlY29kZXJCdWZmZXIuSW5pdChuZXcgSW50OEFycmF5KGJ1ZmZlciksIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBkZWNvZGVHZW9tZXRyeShkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IGF0dHIuYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS5pbmRleClcbiAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGdlb21ldHJ5LmluZGV4LmFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IG1lc3NhZ2UuaWQsIGdlb21ldHJ5IH0sIGJ1ZmZlcnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImVycm9yXCIsIGlkOiBtZXNzYWdlLmlkLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyQnVmZmVyKTtcbiAgICAgICAgICAgIGRyYWNvLmRlc3Ryb3koZGVjb2Rlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkZWNvZGVHZW9tZXRyeShkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZUlEcyA9IHRhc2tDb25maWcuYXR0cmlidXRlSURzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGVzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcztcbiAgICBsZXQgZHJhY29HZW9tZXRyeTtcbiAgICBsZXQgZGVjb2RpbmdTdGF0dXM7XG4gICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gZGVjb2Rlci5HZXRFbmNvZGVkR2VvbWV0cnlUeXBlKGRlY29kZXJCdWZmZXIpO1xuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZHJhY29HZW9tZXRyeSA9IG5ldyBkcmFjby5NZXNoKCk7XG4gICAgICBkZWNvZGluZ1N0YXR1cyA9IGRlY29kZXIuRGVjb2RlQnVmZmVyVG9NZXNoKGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5QT0lOVF9DTE9VRCkge1xuICAgICAgZHJhY29HZW9tZXRyeSA9IG5ldyBkcmFjby5Qb2ludENsb3VkKCk7XG4gICAgICBkZWNvZGluZ1N0YXR1cyA9IGRlY29kZXIuRGVjb2RlQnVmZmVyVG9Qb2ludENsb3VkKGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBnZW9tZXRyeSB0eXBlLlwiKTtcbiAgICB9XG4gICAgaWYgKCFkZWNvZGluZ1N0YXR1cy5vaygpIHx8IGRyYWNvR2VvbWV0cnkucHRyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogRGVjb2RpbmcgZmFpbGVkOiBcIiArIGRlY29kaW5nU3RhdHVzLmVycm9yX21zZygpKTtcbiAgICB9XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB7IGluZGV4OiBudWxsLCBhdHRyaWJ1dGVzOiBbXSB9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVJRHMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSBzZWxmW2F0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgIGxldCBhdHRyaWJ1dGU7XG4gICAgICBsZXQgYXR0cmlidXRlSUQ7XG4gICAgICBpZiAodGFza0NvbmZpZy51c2VVbmlxdWVJRHMpIHtcbiAgICAgICAgYXR0cmlidXRlSUQgPSBhdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlQnlVbmlxdWVJZChkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGRlY29kZXIuR2V0QXR0cmlidXRlSWQoZHJhY29HZW9tZXRyeSwgZHJhY29bYXR0cmlidXRlSURzW2F0dHJpYnV0ZU5hbWVdXSk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVJRCA9PT0gLTEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucHVzaChkZWNvZGVBdHRyaWJ1dGUoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZSkpO1xuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5UUklBTkdVTEFSX01FU0gpIHtcbiAgICAgIGdlb21ldHJ5LmluZGV4ID0gZGVjb2RlSW5kZXgoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH1cbiAgICBkcmFjby5kZXN0cm95KGRyYWNvR2VvbWV0cnkpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSkge1xuICAgIGNvbnN0IG51bUZhY2VzID0gZHJhY29HZW9tZXRyeS5udW1fZmFjZXMoKTtcbiAgICBjb25zdCBudW1JbmRpY2VzID0gbnVtRmFjZXMgKiAzO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBudW1JbmRpY2VzICogNDtcbiAgICBjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKGJ5dGVMZW5ndGgpO1xuICAgIGRlY29kZXIuR2V0VHJpYW5nbGVzVUludDMyQXJyYXkoZHJhY29HZW9tZXRyeSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBpbmRleCA9IG5ldyBVaW50MzJBcnJheShkcmFjby5IRUFQRjMyLmJ1ZmZlciwgcHRyLCBudW1JbmRpY2VzKS5zbGljZSgpO1xuICAgIGRyYWNvLl9mcmVlKHB0cik7XG4gICAgcmV0dXJuIHsgYXJyYXk6IGluZGV4LCBpdGVtU2l6ZTogMSB9O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSB7XG4gICAgY29uc3QgbnVtQ29tcG9uZW50cyA9IGF0dHJpYnV0ZS5udW1fY29tcG9uZW50cygpO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IGRyYWNvR2VvbWV0cnkubnVtX3BvaW50cygpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG51bVBvaW50cyAqIG51bUNvbXBvbmVudHM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bVZhbHVlcyAqIGF0dHJpYnV0ZVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZXREcmFjb0RhdGFUeXBlKGRyYWNvLCBhdHRyaWJ1dGVUeXBlKTtcbiAgICBjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKGJ5dGVMZW5ndGgpO1xuICAgIGRlY29kZXIuR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZSwgZGF0YVR5cGUsIGJ5dGVMZW5ndGgsIHB0cik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgYXR0cmlidXRlVHlwZShkcmFjby5IRUFQRjMyLmJ1ZmZlciwgcHRyLCBudW1WYWx1ZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogYXR0cmlidXRlTmFtZSxcbiAgICAgIGFycmF5LFxuICAgICAgaXRlbVNpemU6IG51bUNvbXBvbmVudHNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpIHtcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfRkxPQVQzMjtcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UODtcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDE2O1xuICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMzI7XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UODtcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMTY7XG4gICAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDMyO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IHtcbiAgRFJBQ09Mb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EUkFDT0xvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJMb2FkZXIiLCJGaWxlTG9hZGVyIiwiQnVmZmVyR2VvbWV0cnkiLCJCdWZmZXJBdHRyaWJ1dGUiLCJfdGFza0NhY2hlIiwiV2Vha01hcCIsIkRSQUNPTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwiZGVjb2RlclBhdGgiLCJkZWNvZGVyQ29uZmlnIiwiZGVjb2RlckJpbmFyeSIsImRlY29kZXJQZW5kaW5nIiwid29ya2VyTGltaXQiLCJ3b3JrZXJQb29sIiwid29ya2VyTmV4dFRhc2tJRCIsIndvcmtlclNvdXJjZVVSTCIsImRlZmF1bHRBdHRyaWJ1dGVJRHMiLCJwb3NpdGlvbiIsIm5vcm1hbCIsImNvbG9yIiwidXYiLCJkZWZhdWx0QXR0cmlidXRlVHlwZXMiLCJzZXREZWNvZGVyUGF0aCIsInBhdGgiLCJzZXREZWNvZGVyQ29uZmlnIiwiY29uZmlnIiwic2V0V29ya2VyTGltaXQiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJsb2FkZXIiLCJzZXRQYXRoIiwic2V0UmVzcG9uc2VUeXBlIiwic2V0UmVxdWVzdEhlYWRlciIsInJlcXVlc3RIZWFkZXIiLCJzZXRXaXRoQ3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJidWZmZXIiLCJ0YXNrQ29uZmlnIiwiYXR0cmlidXRlSURzIiwiYXR0cmlidXRlVHlwZXMiLCJ1c2VVbmlxdWVJRHMiLCJkZWNvZGVHZW9tZXRyeSIsInRoZW4iLCJjYXRjaCIsImRlY29kZURyYWNvRmlsZSIsImNhbGxiYWNrIiwiYXR0cmlidXRlIiwidHlwZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwibmFtZSIsInRhc2tLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFzIiwiY2FjaGVkVGFzayIsImdldCIsImtleSIsInByb21pc2UiLCJieXRlTGVuZ3RoIiwiRXJyb3IiLCJ3b3JrZXIiLCJ0YXNrSUQiLCJ0YXNrQ29zdCIsImdlb21ldHJ5UGVuZGluZyIsIl9nZXRXb3JrZXIiLCJfd29ya2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJfY2FsbGJhY2tzIiwicG9zdE1lc3NhZ2UiLCJpZCIsIm1lc3NhZ2UiLCJfY3JlYXRlR2VvbWV0cnkiLCJnZW9tZXRyeSIsIl9yZWxlYXNlVGFzayIsInNldCIsImdlb21ldHJ5RGF0YSIsImluZGV4Iiwic2V0SW5kZXgiLCJhcnJheSIsImkiLCJhdHRyaWJ1dGVzIiwibGVuZ3RoIiwiaXRlbVNpemUiLCJzZXRBdHRyaWJ1dGUiLCJfbG9hZExpYnJhcnkiLCJyZXNwb25zZVR5cGUiLCJwcmVsb2FkIiwiX2luaXREZWNvZGVyIiwidXNlSlMiLCJXZWJBc3NlbWJseSIsImxpYnJhcmllc1BlbmRpbmciLCJwdXNoIiwiYWxsIiwibGlicmFyaWVzIiwianNDb250ZW50Iiwid2FzbUJpbmFyeSIsImZuIiwiRFJBQ09Xb3JrZXIiLCJ0b1N0cmluZyIsImJvZHkiLCJzdWJzdHJpbmciLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJqb2luIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiQmxvYiIsIndvcmtlcjIiLCJXb3JrZXIiLCJfdGFza0Nvc3RzIiwiX3Rhc2tMb2FkIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJjb25zb2xlIiwiZXJyb3IiLCJzb3J0IiwiYSIsImIiLCJkZWJ1ZyIsImxvZyIsIm1hcCIsImRpc3Bvc2UiLCJ0ZXJtaW5hdGUiLCJvbk1vZHVsZUxvYWRlZCIsImRyYWNvIiwiRHJhY29EZWNvZGVyTW9kdWxlIiwibW9kdWxlIiwiZGVjb2RlciIsIkRlY29kZXIiLCJkZWNvZGVyQnVmZmVyIiwiRGVjb2RlckJ1ZmZlciIsIkluaXQiLCJJbnQ4QXJyYXkiLCJidWZmZXJzIiwiYXR0ciIsInNlbGYiLCJkZXN0cm95IiwiZHJhY29HZW9tZXRyeSIsImRlY29kaW5nU3RhdHVzIiwiZ2VvbWV0cnlUeXBlIiwiR2V0RW5jb2RlZEdlb21ldHJ5VHlwZSIsIlRSSUFOR1VMQVJfTUVTSCIsIk1lc2giLCJEZWNvZGVCdWZmZXJUb01lc2giLCJQT0lOVF9DTE9VRCIsIlBvaW50Q2xvdWQiLCJEZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQiLCJvayIsInB0ciIsImVycm9yX21zZyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVUeXBlIiwiYXR0cmlidXRlSUQiLCJHZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkIiwiR2V0QXR0cmlidXRlSWQiLCJHZXRBdHRyaWJ1dGUiLCJkZWNvZGVBdHRyaWJ1dGUiLCJkZWNvZGVJbmRleCIsIm51bUZhY2VzIiwibnVtX2ZhY2VzIiwibnVtSW5kaWNlcyIsIl9tYWxsb2MiLCJHZXRUcmlhbmdsZXNVSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiSEVBUEYzMiIsInNsaWNlIiwiX2ZyZWUiLCJudW1Db21wb25lbnRzIiwibnVtX2NvbXBvbmVudHMiLCJudW1Qb2ludHMiLCJudW1fcG9pbnRzIiwibnVtVmFsdWVzIiwiZGF0YVR5cGUiLCJnZXREcmFjb0RhdGFUeXBlIiwiR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzIiwiRmxvYXQzMkFycmF5IiwiRFRfRkxPQVQzMiIsIkRUX0lOVDgiLCJJbnQxNkFycmF5IiwiRFRfSU5UMTYiLCJJbnQzMkFycmF5IiwiRFRfSU5UMzIiLCJVaW50OEFycmF5IiwiRFRfVUlOVDgiLCJVaW50MTZBcnJheSIsIkRUX1VJTlQxNiIsIkRUX1VJTlQzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            resourcePath = this.path;\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data)));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === void 0 || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            plugins[plugin.name] = plugin;\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n}\nfunction GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\nconst EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        if (lightDef.color !== void 0) color.fromArray(lightDef.color);\n        const range = lightDef.range !== void 0 ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self2 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === void 0) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self2.cache, lightIndex, light);\n        });\n    }\n}\nclass GLTFMaterialsUnlitExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n        materialParams.opacity = 1;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== void 0) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsClearcoatExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== void 0) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== void 0) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== void 0) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIridescenceExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== void 0) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== void 0) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === void 0) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== void 0) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== void 0) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsSheenExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== void 0) {\n            materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n        }\n        if (extension.sheenRoughnessFactor !== void 0) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, 3001));\n        }\n        if (extension.sheenRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsTransmissionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== void 0) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsVolumeExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIorExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsSpecularExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n        if (extension.specularTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        if (extension.specularColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, 3001));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsAnisotropyExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== void 0) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== void 0) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFTextureBasisUExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n}\nclass GLTFTextureWebPExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFTextureAVIFExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFMeshoptCompression {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n                        return res2.buffer;\n                    });\n                } else {\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n}\nclass GLTFMeshGpuInstancing {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count;\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                for(const attributeName in attributes){\n                    if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 1313821514,\n    BIN: 5130562\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        this.header = {\n            magic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\nclass GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== void 0) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== void 0) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap);\n            });\n        });\n    }\n}\nclass GLTFTextureTransformExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== void 0) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== void 0) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== void 0) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== void 0) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n}\nclass GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride];\n            const m0 = values[offset0 + i + stride2] * td;\n            const p1 = values[offset1 + i + stride];\n            const m1 = values[offset1 + i] * td;\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\nconst WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    // uv => uv1, 4 uv channels\n    // https://github.com/mrdoob/three.js/pull/25943\n    // https://github.com/mrdoob/three.js/pull/25788\n    ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 152 ? {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv1\",\n        TEXCOORD_2: \"uv2\",\n        TEXCOORD_3: \"uv3\"\n    } : {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv2\"\n    },\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: void 0,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === void 0) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 16777215,\n            emissive: 0,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === void 0) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== void 0) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== void 0) hasMorphPosition = true;\n        if (target.NORMAL !== void 0) hasMorphNormal = true;\n        if (target.COLOR_0 !== void 0) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== void 0) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== void 0) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        this.cache = new GLTFRegistry();\n        this.associations = /* @__PURE__ */ new Map();\n        this.primitiveCache = {};\n        this.nodeCache = {};\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        this.nodeNamesUsed = {};\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        this.cache.removeAll();\n        this.nodeCache = {};\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== void 0) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                if (nodeDef.skin !== void 0) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== void 0) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */ _addNodeRef(cache, index) {\n        if (index === void 0) return;\n        if (cache.refs[index] === void 0) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        if (bufferDef.uri === void 0 && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            if (byteStride && byteStride !== itemBytes) {\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            if (accessorDef.sparse !== void 0) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== void 0) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== void 0) {\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === void 0) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n            });\n        }).then(function(texture) {\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */ assignTexture(materialParams, mapName, mapDef, encoding) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (encoding !== void 0) {\n                if (\"colorSpace\" in texture) texture.colorSpace = encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n                else texture.encoding = encoding;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === void 0;\n        const useVertexColors = geometry.attributes.color !== void 0;\n        const useFlatShading = geometry.attributes.normal === void 0;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false;\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n            if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== void 0) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== void 0) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(materialDef.emissiveFactor);\n        }\n        if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, 3001));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            const cached = cache[cacheKey];\n            if (cached) {\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                cache[cacheKey] = {\n                    primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== void 0) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === void 0) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === void 0) continue;\n                node.updateMatrix();\n                let TypedKeyframeTrack;\n                switch(PATH_PROPERTIES[target.path]){\n                    case PATH_PROPERTIES.weights:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.rotation:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.position:\n                    case PATH_PROPERTIES.scale:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                const targetName = node.name ? node.name : node.uuid;\n                const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n                const targetNames = [];\n                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n                    node.traverse(function(object) {\n                        if (object.morphTargetInfluences) {\n                            targetNames.push(object.name ? object.name : object.uuid);\n                        }\n                    });\n                } else {\n                    targetNames.push(targetName);\n                }\n                let outputArray = outputAccessor.array;\n                if (outputAccessor.normalized) {\n                    const scale = getNormalizedComponentScale(outputArray.constructor);\n                    const scaled = new Float32Array(outputArray.length);\n                    for(let j = 0, jl = outputArray.length; j < jl; j++){\n                        scaled[j] = outputArray[j] * scale;\n                    }\n                    outputArray = scaled;\n                }\n                for(let j = 0, jl = targetNames.length; j < jl; j++){\n                    const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n                    if (sampler.interpolation === \"CUBICSPLINE\") {\n                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n                            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n                        };\n                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n                    }\n                    tracks.push(track);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === void 0) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            if (nodeDef.weights !== void 0) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        if (this.nodeCache[nodeIndex] !== void 0) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== void 0) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== void 0) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== void 0) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== void 0) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== void 0) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = /* @__PURE__ */ new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node2)=>{\n                    const mappings = parser.associations.get(node2);\n                    if (mappings != null) {\n                        reducedAssociations.set(node2, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== void 0) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== void 0) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== void 0) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                if (min !== void 0 && max !== void 0) {\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== void 0 && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n            geometry.setIndex(accessor2);\n        });\n        pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n //# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWc4QjtBQUMxM0I7QUFDbEI7QUFDcEQsTUFBTStELG1CQUFtQi9ELHlDQUFNQTtJQUM3QmdFLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUNDLFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUMsZ0NBQWdDRDtRQUM3QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJRSwyQkFBMkJGO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlHLHlCQUF5Qkg7UUFDdEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUkseUJBQXlCSjtRQUN0QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJSyw0QkFBNEJMO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlNLG1DQUFtQ047UUFDaEQ7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSU8sNkJBQTZCUDtRQUMxQztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJUSwwQkFBMEJSO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlTLHVD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QUFDLFNBQVN5SCxRQUFRO1lBQzNFWSxTQUFTUyxZQUFZLENBQUNELGVBQWVwQjtRQUN2QztJQUNGO0lBQ0EsSUFBSyxNQUFNc2MscUJBQXFCdmMsV0FBWTtRQUMxQyxNQUFNaUQscUJBQXFCQyxVQUFVLENBQUNxWixrQkFBa0IsSUFBSUEsa0JBQWtCcFosV0FBVztRQUN6RixJQUFJRixzQkFBc0JwQyxTQUFTYixVQUFVLEVBQzNDO1FBQ0ZsSCxRQUFRbEgsSUFBSSxDQUFDMHFCLHdCQUF3QnRjLFVBQVUsQ0FBQ3VjLGtCQUFrQixFQUFFdFo7SUFDdEU7SUFDQSxJQUFJMkksYUFBYUcsT0FBTyxLQUFLLEtBQUssS0FBSyxDQUFDbEwsU0FBU3hJLEtBQUssRUFBRTtRQUN0RCxNQUFNNEgsV0FBV3RSLE9BQU95SixhQUFhLENBQUMsWUFBWXdULGFBQWFHLE9BQU8sRUFBRXZULElBQUksQ0FBQyxTQUFTZ2tCLFNBQVM7WUFDN0YzYixTQUFTNGIsUUFBUSxDQUFDRDtRQUNwQjtRQUNBMWpCLFFBQVFsSCxJQUFJLENBQUNxTztJQUNmO0lBQ0FoSSx1QkFBdUI0SSxVQUFVK0s7SUFDakN5UCxjQUFjeGEsVUFBVStLLGNBQWNqZDtJQUN0QyxPQUFPeUYsUUFBUW9GLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDO1FBQy9CLE9BQU9vVCxhQUFhcEIsT0FBTyxLQUFLLEtBQUssSUFBSUQsZ0JBQWdCMUosVUFBVStLLGFBQWFwQixPQUFPLEVBQUU3YixVQUFVa1M7SUFDckc7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcz9iZmMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgTG9hZGVyVXRpbHMsIEZpbGVMb2FkZXIsIENvbG9yLCBTcG90TGlnaHQsIFBvaW50TGlnaHQsIERpcmVjdGlvbmFsTGlnaHQsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoUGh5c2ljYWxNYXRlcmlhbCwgVmVjdG9yMiwgTWF0cml4NCwgVmVjdG9yMywgUXVhdGVybmlvbiwgSW5zdGFuY2VkTWVzaCwgT2JqZWN0M0QsIFRleHR1cmVMb2FkZXIsIEltYWdlQml0bWFwTG9hZGVyLCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFJlcGVhdFdyYXBwaW5nLCBQb2ludHNNYXRlcmlhbCwgTWF0ZXJpYWwsIExpbmVCYXNpY01hdGVyaWFsLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSwgUHJvcGVydHlCaW5kaW5nLCBCdWZmZXJHZW9tZXRyeSwgU2tpbm5lZE1lc2gsIE1lc2gsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgTGluZVNlZ21lbnRzLCBMaW5lLCBMaW5lTG9vcCwgUG9pbnRzLCBHcm91cCwgUGVyc3BlY3RpdmVDYW1lcmEsIE1hdGhVdGlscywgT3J0aG9ncmFwaGljQ2FtZXJhLCBTa2VsZXRvbiwgSW50ZXJwb2xhdGVMaW5lYXIsIEFuaW1hdGlvbkNsaXAsIEJvbmUsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBJbnRlcnBvbGF0ZURpc2NyZXRlLCBGcm9udFNpZGUsIFRleHR1cmUsIFZlY3RvcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBOdW1iZXJLZXlmcmFtZVRyYWNrLCBCb3gzLCBTcGhlcmUsIEludGVycG9sYW50IH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB0b1RyaWFuZ2xlc0RyYXdNb2RlIH0gZnJvbSBcIi4uL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuY2xhc3MgR0xURkxvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBudWxsO1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZMaWdodHNFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaG9wdENvbXByZXNzaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1lc2hHcHVJbnN0YW5jaW5nKHBhcnNlcik7XG4gICAgfSk7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBsZXQgcmVzb3VyY2VQYXRoO1xuICAgIGlmICh0aGlzLnJlc291cmNlUGF0aCAhPT0gXCJcIikge1xuICAgICAgcmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhdGggIT09IFwiXCIpIHtcbiAgICAgIHJlc291cmNlUGF0aCA9IHRoaXMucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKTtcbiAgICB9XG4gICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgIGNvbnN0IF9vbkVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2NvcGUucGFyc2UoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVzb3VyY2VQYXRoLFxuICAgICAgICAgICAgZnVuY3Rpb24oZ2x0Zikge1xuICAgICAgICAgICAgICBvbkxvYWQoZ2x0Zik7XG4gICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIF9vbkVycm9yXG4gICAgKTtcbiAgfVxuICBzZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcikge1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRERFNMb2FkZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJyk7XG4gIH1cbiAgc2V0S1RYMkxvYWRlcihrdHgyTG9hZGVyKSB7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRNZXNob3B0RGVjb2RlcihtZXNob3B0RGVjb2Rlcikge1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2RlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spICE9PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgbGV0IGpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBtYWdpYyA9IExvYWRlclV0aWxzLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgaWYgKG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShMb2FkZXJVdGlscy5kZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzb24gPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoanNvbi5hc3NldCA9PT0gdm9pZCAwIHx8IGpzb24uYXNzZXQudmVyc2lvblswXSA8IDIpIHtcbiAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoanNvbiwge1xuICAgICAgcGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCBcIlwiLFxuICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICByZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG4gICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG4gICAgICBrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG4gICAgICBtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuICAgIH0pO1xuICAgIHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1tpXShwYXJzZXIpO1xuICAgICAgcGx1Z2luc1twbHVnaW4ubmFtZV0gPSBwbHVnaW47XG4gICAgICBleHRlbnNpb25zW3BsdWdpbi5uYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChqc29uLmV4dGVuc2lvbnNVc2VkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24uZXh0ZW5zaW9uc1VzZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZSA9IGpzb24uZXh0ZW5zaW9uc1VzZWRbaV07XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnNSZXF1aXJlZCA9IGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkIHx8IFtdO1xuICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbk5hbWUpIHtcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbihqc29uLCB0aGlzLmRyYWNvTG9hZGVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihleHRlbnNpb25OYW1lKSA+PSAwICYmIHBsdWdpbnNbZXh0ZW5zaW9uTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IFVua25vd24gZXh0ZW5zaW9uIFwiJyArIGV4dGVuc2lvbk5hbWUgKyAnXCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VyLnNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgcGFyc2VyLnNldFBsdWdpbnMocGx1Z2lucyk7XG4gICAgcGFyc2VyLnBhcnNlKG9uTG9hZCwgb25FcnJvcik7XG4gIH1cbiAgcGFyc2VBc3luYyhkYXRhLCBwYXRoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNjb3BlLnBhcnNlKGRhdGEsIHBhdGgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEdMVEZSZWdpc3RyeSgpIHtcbiAgbGV0IG9iamVjdHMgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdHNba2V5XTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24oa2V5LCBvYmplY3QpIHtcbiAgICAgIG9iamVjdHNba2V5XSA9IG9iamVjdDtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZWxldGUgb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIG9iamVjdHMgPSB7fTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBFWFRFTlNJT05TID0ge1xuICBLSFJfQklOQVJZX0dMVEY6IFwiS0hSX2JpbmFyeV9nbFRGXCIsXG4gIEtIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOiBcIktIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXCIsXG4gIEtIUl9MSUdIVFNfUFVOQ1RVQUw6IFwiS0hSX2xpZ2h0c19wdW5jdHVhbFwiLFxuICBLSFJfTUFURVJJQUxTX0NMRUFSQ09BVDogXCJLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdFwiLFxuICBLSFJfTUFURVJJQUxTX0lPUjogXCJLSFJfbWF0ZXJpYWxzX2lvclwiLFxuICBLSFJfTUFURVJJQUxTX1NIRUVOOiBcIktIUl9tYXRlcmlhbHNfc2hlZW5cIixcbiAgS0hSX01BVEVSSUFMU19TUEVDVUxBUjogXCJLSFJfbWF0ZXJpYWxzX3NwZWN1bGFyXCIsXG4gIEtIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OOiBcIktIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U6IFwiS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZVwiLFxuICBLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk6IFwiS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5XCIsXG4gIEtIUl9NQVRFUklBTFNfVU5MSVQ6IFwiS0hSX21hdGVyaWFsc191bmxpdFwiLFxuICBLSFJfTUFURVJJQUxTX1ZPTFVNRTogXCJLSFJfbWF0ZXJpYWxzX3ZvbHVtZVwiLFxuICBLSFJfVEVYVFVSRV9CQVNJU1U6IFwiS0hSX3RleHR1cmVfYmFzaXN1XCIsXG4gIEtIUl9URVhUVVJFX1RSQU5TRk9STTogXCJLSFJfdGV4dHVyZV90cmFuc2Zvcm1cIixcbiAgS0hSX01FU0hfUVVBTlRJWkFUSU9OOiBcIktIUl9tZXNoX3F1YW50aXphdGlvblwiLFxuICBLSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIOiBcIktIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGhcIixcbiAgRVhUX1RFWFRVUkVfV0VCUDogXCJFWFRfdGV4dHVyZV93ZWJwXCIsXG4gIEVYVF9URVhUVVJFX0FWSUY6IFwiRVhUX3RleHR1cmVfYXZpZlwiLFxuICBFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiLFxuICBFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORzogXCJFWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1wiXG59O1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcbiAgICB0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgfVxuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQgIT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZXIuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfbG9hZExpZ2h0KGxpZ2h0SW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBjYWNoZUtleSA9IFwibGlnaHQ6XCIgKyBsaWdodEluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGRlcGVuZGVuY3kpXG4gICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodERlZnMgPSBleHRlbnNpb25zLmxpZ2h0cyB8fCBbXTtcbiAgICBjb25zdCBsaWdodERlZiA9IGxpZ2h0RGVmc1tsaWdodEluZGV4XTtcbiAgICBsZXQgbGlnaHROb2RlO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KTtcbiAgICBpZiAobGlnaHREZWYuY29sb3IgIT09IHZvaWQgMClcbiAgICAgIGNvbG9yLmZyb21BcnJheShsaWdodERlZi5jb2xvcik7XG4gICAgY29uc3QgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdm9pZCAwID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuICAgIHN3aXRjaCAobGlnaHREZWYudHlwZSkge1xuICAgICAgY2FzZSBcImRpcmVjdGlvbmFsXCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgUG9pbnRMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzcG90XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgbGlnaHREZWYuc3BvdCA9IGxpZ2h0RGVmLnNwb3QgfHwge307XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIDogMDtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgOiBNYXRoLlBJIC8gNDtcbiAgICAgICAgbGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnBlbnVtYnJhID0gMSAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiBcIiArIGxpZ2h0RGVmLnR5cGUpO1xuICAgIH1cbiAgICBsaWdodE5vZGUucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShsaWdodE5vZGUsIGxpZ2h0RGVmKTtcbiAgICBpZiAobGlnaHREZWYuaW50ZW5zaXR5ICE9PSB2b2lkIDApXG4gICAgICBsaWdodE5vZGUuaW50ZW5zaXR5ID0gbGlnaHREZWYuaW50ZW5zaXR5O1xuICAgIGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobGlnaHREZWYubmFtZSB8fCBcImxpZ2h0X1wiICsgbGlnaHRJbmRleCk7XG4gICAgZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZShsaWdodE5vZGUpO1xuICAgIHBhcnNlci5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZSAhPT0gXCJsaWdodFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQoaW5kZXgpO1xuICB9XG4gIGNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBsaWdodERlZiA9IG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG4gICAgaWYgKGxpZ2h0SW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQobGlnaHRJbmRleCkudGhlbihmdW5jdGlvbihsaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihzZWxmMi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheShhcnJheSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCAzMDAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBlbWlzc2l2ZVN0cmVuZ3RoID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmVtaXNzaXZlU3RyZW5ndGg7XG4gICAgaWYgKGVtaXNzaXZlU3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBlbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdCA9IGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0TWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdFJvdWdobmVzcyA9IGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Um91Z2huZXNzTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Tm9ybWFsTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlKSk7XG4gICAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2UgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJpcmlkZXNjZW5jZU1hcFwiLCBleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VJb3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VJT1IgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VJb3I7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID09PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBbMTAwLCA0MDBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzBdID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVsxXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VUaGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NIRUVOO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigwLCAwLCAwKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IDA7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW4gPSAxO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvci5mcm9tQXJyYXkoZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3IpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzaGVlbkNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zaGVlbkNvbG9yVGV4dHVyZSwgMzAwMSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Sb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zbWlzc2lvbiA9IGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidHJhbnNtaXNzaW9uTWFwXCIsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMudGhpY2tuZXNzID0gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciA6IDA7XG4gICAgaWYgKGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0aGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkRpc3RhbmNlIHx8IEluZmluaXR5O1xuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvcihjb2xvckFycmF5WzBdLCBjb2xvckFycmF5WzFdLCBjb2xvckFycmF5WzJdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSU9SO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuaW9yID0gZXh0ZW5zaW9uLmlvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmlvciA6IDEuNTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TUEVDVUxBUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckludGVuc2l0eSA9IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJJbnRlbnNpdHlNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSkpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JGYWN0b3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoY29sb3JBcnJheVswXSwgY29sb3JBcnJheVsxXSwgY29sb3JBcnJheVsyXSk7XG4gICAgaWYgKGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNwZWN1bGFyQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JUZXh0dXJlLCAzMDAxKVxuICAgICAgICAvLyBzUkdCRW5jb2RpbmdcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQU5JU09UUk9QWTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5hbmlzb3Ryb3B5ID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aDtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weVJvdGF0aW9uID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlSb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYW5pc290cm9weU1hcFwiLCBleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfQkFTSVNVO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGNvbnN0IGxvYWRlciA9IHBhcnNlci5vcHRpb25zLmt0eDJMb2FkZXI7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKHRoaXMubmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRLVFgyTG9hZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIEtUWDIgdGV4dHVyZXNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9XRUJQO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogV2ViUCByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUFcIjtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UuaGVpZ2h0ID09PSAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9BVklGO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQVZJRiByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUJjQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFFQUFBQUJBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRQU1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFCb0FBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQjl0WkdGMEVnQUtDQmdBQm9nUUVEUWdNZ2tRQUFBQUI4ZFNMZkk9XCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNob3B0Q29tcHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGxvYWRCdWZmZXJWaWV3KGluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG4gICAgY29uc3QgYnVmZmVyVmlldyA9IGpzb24uYnVmZmVyVmlld3NbaW5kZXhdO1xuICAgIGlmIChidWZmZXJWaWV3LmV4dGVuc2lvbnMgJiYgYnVmZmVyVmlldy5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkRlZiA9IGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBleHRlbnNpb25EZWYuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSB0aGlzLnBhcnNlci5vcHRpb25zLm1lc2hvcHREZWNvZGVyO1xuICAgICAgaWYgKCFkZWNvZGVyIHx8ICFkZWNvZGVyLnN1cHBvcnRlZCkge1xuICAgICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRNZXNob3B0RGVjb2RlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBjb21wcmVzc2VkIGZpbGVzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBleHRlbnNpb25EZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gZXh0ZW5zaW9uRGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgICAgY29uc3QgY291bnQgPSBleHRlbnNpb25EZWYuY291bnQ7XG4gICAgICAgIGNvbnN0IHN0cmlkZSA9IGV4dGVuc2lvbkRlZi5ieXRlU3RyaWRlO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgVWludDhBcnJheShyZXMsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAoZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMoY291bnQsIHN0cmlkZSwgc291cmNlLCBleHRlbnNpb25EZWYubW9kZSwgZXh0ZW5zaW9uRGVmLmZpbHRlcikudGhlbihmdW5jdGlvbihyZXMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzMi5idWZmZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIucmVhZHkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihjb3VudCAqIHN0cmlkZSk7XG4gICAgICAgICAgICBkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXIoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCksXG4gICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uRGVmLm1vZGUsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5maWx0ZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHTFRGTWVzaEdwdUluc3RhbmNpbmcge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKCFub2RlRGVmLmV4dGVuc2lvbnMgfHwgIW5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW25vZGVEZWYubWVzaF07XG4gICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgbWVzaERlZi5wcmltaXRpdmVzKSB7XG4gICAgICBpZiAocHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCAmJiBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiAmJiBwcmltaXRpdmUubW9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25EZWYgPSBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzRGVmID0gZXh0ZW5zaW9uRGVmLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzRGVmKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBhdHRyaWJ1dGVzRGVmW2tleV0pLnRoZW4oKGFjY2Vzc29yKSA9PiB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYWNjZXNzb3I7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwZW5kaW5nLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2godGhpcy5wYXJzZXIuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVPYmplY3QgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3QgbWVzaGVzID0gbm9kZU9iamVjdC5pc0dyb3VwID8gbm9kZU9iamVjdC5jaGlsZHJlbiA6IFtub2RlT2JqZWN0XTtcbiAgICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0c1swXS5jb3VudDtcbiAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBtZXNoIG9mIG1lc2hlcykge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICBjb25zdCBzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2ggPSBuZXcgSW5zdGFuY2VkTWVzaChtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdGVyaWFsLCBjb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlRSQU5TTEFUSU9OKSB7XG4gICAgICAgICAgICBwLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5UUkFOU0xBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlJPVEFUSU9OKSB7XG4gICAgICAgICAgICBxLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5ST1RBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlNDQUxFKSB7XG4gICAgICAgICAgICBzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5TQ0FMRSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQoaSwgbS5jb21wb3NlKHAsIHEsIHMpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lICE9PSBcIlRSQU5TTEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJST1RBVElPTlwiICYmIGF0dHJpYnV0ZU5hbWUgIT09IFwiU0NBTEVcIikge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoaW5zdGFuY2VkTWVzaCwgbWVzaCk7XG4gICAgICAgIHRoaXMucGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwoaW5zdGFuY2VkTWVzaCk7XG4gICAgICAgIGluc3RhbmNlZE1lc2hlcy5wdXNoKGluc3RhbmNlZE1lc2gpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVPYmplY3QuaXNHcm91cCkge1xuICAgICAgICBub2RlT2JqZWN0LmNsZWFyKCk7XG4gICAgICAgIG5vZGVPYmplY3QuYWRkKC4uLmluc3RhbmNlZE1lc2hlcyk7XG4gICAgICAgIHJldHVybiBub2RlT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlZE1lc2hlc1swXTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgPSBcImdsVEZcIjtcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCA9IDEyO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyA9IHsgSlNPTjogMTMxMzgyMTUxNCwgQklOOiA1MTMwNTYyIH07XG5jbGFzcyBHTFRGQmluYXJ5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGO1xuICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICBjb25zdCBoZWFkZXJWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEsIDAsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCk7XG4gICAgdGhpcy5oZWFkZXIgPSB7XG4gICAgICBtYWdpYzogTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIDQpKSksXG4gICAgICB2ZXJzaW9uOiBoZWFkZXJWaWV3LmdldFVpbnQzMig0LCB0cnVlKSxcbiAgICAgIGxlbmd0aDogaGVhZGVyVmlldy5nZXRVaW50MzIoOCwgdHJ1ZSlcbiAgICB9O1xuICAgIGlmICh0aGlzLmhlYWRlci5tYWdpYyAhPT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGdsVEYtQmluYXJ5IGhlYWRlci5cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhlYWRlci52ZXJzaW9uIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtDb250ZW50c0xlbmd0aCA9IHRoaXMuaGVhZGVyLmxlbmd0aCAtIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSDtcbiAgICBjb25zdCBjaHVua1ZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgd2hpbGUgKGNodW5rSW5kZXggPCBjaHVua0NvbnRlbnRzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaHVua0xlbmd0aCA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVua1ZpZXcuZ2V0VWludDMyKGNodW5rSW5kZXgsIHRydWUpO1xuICAgICAgY2h1bmtJbmRleCArPSA0O1xuICAgICAgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5KU09OKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXgsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChjb250ZW50QXJyYXkpO1xuICAgICAgfSBlbHNlIGlmIChjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuQklOKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4O1xuICAgICAgICB0aGlzLmJvZHkgPSBkYXRhLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBjaHVua0xlbmd0aCk7XG4gICAgICB9XG4gICAgICBjaHVua0luZGV4ICs9IGNodW5rTGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBKU09OIGNvbnRlbnQgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGpzb24sIGRyYWNvTG9hZGVyKSB7XG4gICAgaWYgKCFkcmFjb0xvYWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogTm8gRFJBQ09Mb2FkZXIgaW5zdGFuY2UgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OO1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIucHJlbG9hZCgpO1xuICB9XG4gIGRlY29kZVByaW1pdGl2ZShwcmltaXRpdmUsIHBhcnNlcikge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZHJhY29Mb2FkZXIgPSB0aGlzLmRyYWNvTG9hZGVyO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdJbmRleCA9IHByaW1pdGl2ZS5leHRlbnNpb25zW3RoaXMubmFtZV0uYnVmZmVyVmlldztcbiAgICBjb25zdCBnbHRmQXR0cmlidXRlTWFwID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlTm9ybWFsaXplZE1hcCA9IHt9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGVNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2x0ZkF0dHJpYnV0ZU1hcCkge1xuICAgICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1thdHRyaWJ1dGVOYW1lXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aHJlZUF0dHJpYnV0ZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gZ2x0ZkF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHByaW1pdGl2ZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgYWNjZXNzb3JEZWYgPSBqc29uLmFjY2Vzc29yc1twcmltaXRpdmUuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFR5cGUgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICAgIGF0dHJpYnV0ZVR5cGVNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICAgICAgYXR0cmlidXRlTm9ybWFsaXplZE1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBidWZmZXJWaWV3SW5kZXgpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlldykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgZHJhY29Mb2FkZXIuZGVjb2RlRHJhY29GaWxlKFxuICAgICAgICAgIGJ1ZmZlclZpZXcsXG4gICAgICAgICAgZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZ2VvbWV0cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyZWVBdHRyaWJ1dGVNYXAsXG4gICAgICAgICAgYXR0cmlidXRlVHlwZU1hcFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk07XG4gIH1cbiAgZXh0ZW5kVGV4dHVyZSh0ZXh0dXJlLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoKHRyYW5zZm9ybS50ZXhDb29yZCA9PT0gdm9pZCAwIHx8IHRyYW5zZm9ybS50ZXhDb29yZCA9PT0gdGV4dHVyZS5jaGFubmVsKSAmJiB0cmFuc2Zvcm0ub2Zmc2V0ID09PSB2b2lkIDAgJiYgdHJhbnNmb3JtLnJvdGF0aW9uID09PSB2b2lkIDAgJiYgdHJhbnNmb3JtLnNjYWxlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICB0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgIGlmICh0cmFuc2Zvcm0udGV4Q29vcmQgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5jaGFubmVsID0gdHJhbnNmb3JtLnRleENvb3JkO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLm9mZnNldCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkodHJhbnNmb3JtLm9mZnNldCk7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ucm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5yb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkodHJhbnNmb3JtLnNjYWxlKTtcbiAgICB9XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT047XG4gIH1cbn1cbmNsYXNzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG4gICAgc3VwZXIocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcik7XG4gIH1cbiAgY29weVNhbXBsZVZhbHVlXyhpbmRleCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLCB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcywgdmFsdWVTaXplID0gdGhpcy52YWx1ZVNpemUsIG9mZnNldCA9IGluZGV4ICogdmFsdWVTaXplICogMyArIHZhbHVlU2l6ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmFsdWVTaXplOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHZhbHVlc1tvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyO1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzO1xuICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzdHJpZGUgKiAyO1xuICAgIGNvbnN0IHN0cmlkZTMgPSBzdHJpZGUgKiAzO1xuICAgIGNvbnN0IHRkID0gdDEgLSB0MDtcbiAgICBjb25zdCBwID0gKHQgLSB0MCkgLyB0ZDtcbiAgICBjb25zdCBwcCA9IHAgKiBwO1xuICAgIGNvbnN0IHBwcCA9IHBwICogcDtcbiAgICBjb25zdCBvZmZzZXQxID0gaTEgKiBzdHJpZGUzO1xuICAgIGNvbnN0IG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlMztcbiAgICBjb25zdCBzMiA9IC0yICogcHBwICsgMyAqIHBwO1xuICAgIGNvbnN0IHMzID0gcHBwIC0gcHA7XG4gICAgY29uc3QgczAgPSAxIC0gczI7XG4gICAgY29uc3QgczEgPSBzMyAtIHBwICsgcDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyBpKyspIHtcbiAgICAgIGNvbnN0IHAwID0gdmFsdWVzW29mZnNldDAgKyBpICsgc3RyaWRlXTtcbiAgICAgIGNvbnN0IG0wID0gdmFsdWVzW29mZnNldDAgKyBpICsgc3RyaWRlMl0gKiB0ZDtcbiAgICAgIGNvbnN0IHAxID0gdmFsdWVzW29mZnNldDEgKyBpICsgc3RyaWRlXTtcbiAgICAgIGNvbnN0IG0xID0gdmFsdWVzW29mZnNldDEgKyBpXSAqIHRkO1xuICAgICAgcmVzdWx0W2ldID0gczAgKiBwMCArIHMxICogbTAgKyBzMiAqIHAxICsgczMgKiBtMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgX3EgPSBuZXcgUXVhdGVybmlvbigpO1xuY2xhc3MgR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IGV4dGVuZHMgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQge1xuICBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKTtcbiAgICBfcS5mcm9tQXJyYXkocmVzdWx0KS5ub3JtYWxpemUoKS50b0FycmF5KHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgV0VCR0xfQ09OU1RBTlRTID0ge1xuICBGTE9BVDogNTEyNixcbiAgLy9GTE9BVF9NQVQyOiAzNTY3NCxcbiAgRkxPQVRfTUFUMzogMzU2NzUsXG4gIEZMT0FUX01BVDQ6IDM1Njc2LFxuICBGTE9BVF9WRUMyOiAzNTY2NCxcbiAgRkxPQVRfVkVDMzogMzU2NjUsXG4gIEZMT0FUX1ZFQzQ6IDM1NjY2LFxuICBMSU5FQVI6IDk3MjksXG4gIFJFUEVBVDogMTA0OTcsXG4gIFNBTVBMRVJfMkQ6IDM1Njc4LFxuICBQT0lOVFM6IDAsXG4gIExJTkVTOiAxLFxuICBMSU5FX0xPT1A6IDIsXG4gIExJTkVfU1RSSVA6IDMsXG4gIFRSSUFOR0xFUzogNCxcbiAgVFJJQU5HTEVfU1RSSVA6IDUsXG4gIFRSSUFOR0xFX0ZBTjogNixcbiAgVU5TSUdORURfQllURTogNTEyMSxcbiAgVU5TSUdORURfU0hPUlQ6IDUxMjNcbn07XG5jb25zdCBXRUJHTF9DT01QT05FTlRfVFlQRVMgPSB7XG4gIDUxMjA6IEludDhBcnJheSxcbiAgNTEyMTogVWludDhBcnJheSxcbiAgNTEyMjogSW50MTZBcnJheSxcbiAgNTEyMzogVWludDE2QXJyYXksXG4gIDUxMjU6IFVpbnQzMkFycmF5LFxuICA1MTI2OiBGbG9hdDMyQXJyYXlcbn07XG5jb25zdCBXRUJHTF9GSUxURVJTID0ge1xuICA5NzI4OiBOZWFyZXN0RmlsdGVyLFxuICA5NzI5OiBMaW5lYXJGaWx0ZXIsXG4gIDk5ODQ6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg1OiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg2OiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuICA5OTg3OiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn07XG5jb25zdCBXRUJHTF9XUkFQUElOR1MgPSB7XG4gIDMzMDcxOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAzMzY0ODogTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcbiAgMTA0OTc6IFJlcGVhdFdyYXBwaW5nXG59O1xuY29uc3QgV0VCR0xfVFlQRV9TSVpFUyA9IHtcbiAgU0NBTEFSOiAxLFxuICBWRUMyOiAyLFxuICBWRUMzOiAzLFxuICBWRUM0OiA0LFxuICBNQVQyOiA0LFxuICBNQVQzOiA5LFxuICBNQVQ0OiAxNlxufTtcbmNvbnN0IEFUVFJJQlVURVMgPSB7XG4gIFBPU0lUSU9OOiBcInBvc2l0aW9uXCIsXG4gIE5PUk1BTDogXCJub3JtYWxcIixcbiAgVEFOR0VOVDogXCJ0YW5nZW50XCIsXG4gIC8vIHV2ID0+IHV2MSwgNCB1diBjaGFubmVsc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU5NDNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1Nzg4XG4gIC4uLnZlcnNpb24gPj0gMTUyID8ge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MVwiLFxuICAgIFRFWENPT1JEXzI6IFwidXYyXCIsXG4gICAgVEVYQ09PUkRfMzogXCJ1djNcIlxuICB9IDoge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MlwiXG4gIH0sXG4gIENPTE9SXzA6IFwiY29sb3JcIixcbiAgV0VJR0hUU18wOiBcInNraW5XZWlnaHRcIixcbiAgSk9JTlRTXzA6IFwic2tpbkluZGV4XCJcbn07XG5jb25zdCBQQVRIX1BST1BFUlRJRVMgPSB7XG4gIHNjYWxlOiBcInNjYWxlXCIsXG4gIHRyYW5zbGF0aW9uOiBcInBvc2l0aW9uXCIsXG4gIHJvdGF0aW9uOiBcInF1YXRlcm5pb25cIixcbiAgd2VpZ2h0czogXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIlxufTtcbmNvbnN0IElOVEVSUE9MQVRJT04gPSB7XG4gIENVQklDU1BMSU5FOiB2b2lkIDAsXG4gIC8vIFdlIHVzZSBhIGN1c3RvbSBpbnRlcnBvbGFudCAoR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhdGlvbikgZm9yIENVQklDU1BMSU5FIHRyYWNrcy4gRWFjaFxuICAvLyBrZXlmcmFtZSB0cmFjayB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSwgdGhlbiBtb2RpZmllZC5cbiAgTElORUFSOiBJbnRlcnBvbGF0ZUxpbmVhcixcbiAgU1RFUDogSW50ZXJwb2xhdGVEaXNjcmV0ZVxufTtcbmNvbnN0IEFMUEhBX01PREVTID0ge1xuICBPUEFRVUU6IFwiT1BBUVVFXCIsXG4gIE1BU0s6IFwiTUFTS1wiLFxuICBCTEVORDogXCJCTEVORFwiXG59O1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKGNhY2hlKSB7XG4gIGlmIChjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9PT0gdm9pZCAwKSB7XG4gICAgY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl0gPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgZW1pc3NpdmU6IDAsXG4gICAgICBtZXRhbG5lc3M6IDEsXG4gICAgICByb3VnaG5lc3M6IDEsXG4gICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IHRydWUsXG4gICAgICBzaWRlOiBGcm9udFNpZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl07XG59XG5mdW5jdGlvbiBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoa25vd25FeHRlbnNpb25zLCBvYmplY3QsIG9iamVjdERlZikge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqZWN0RGVmLmV4dGVuc2lvbnMpIHtcbiAgICBpZiAoa25vd25FeHRlbnNpb25zW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyA9IG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyB8fCB7fTtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9uc1tuYW1lXSA9IG9iamVjdERlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShvYmplY3QsIGdsdGZEZWYpIHtcbiAgaWYgKGdsdGZEZWYuZXh0cmFzICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIGdsdGZEZWYuZXh0cmFzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG9iamVjdC51c2VyRGF0YSwgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJZ25vcmluZyBwcmltaXRpdmUgdHlwZSAuZXh0cmFzLCBcIiArIGdsdGZEZWYuZXh0cmFzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZE1vcnBoVGFyZ2V0cyhnZW9tZXRyeSwgdGFyZ2V0cywgcGFyc2VyKSB7XG4gIGxldCBoYXNNb3JwaFBvc2l0aW9uID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaE5vcm1hbCA9IGZhbHNlO1xuICBsZXQgaGFzTW9ycGhDb2xvciA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoUG9zaXRpb24gPSB0cnVlO1xuICAgIGlmICh0YXJnZXQuTk9STUFMICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaE5vcm1hbCA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaENvbG9yID0gdHJ1ZTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbiAmJiBoYXNNb3JwaE5vcm1hbCAmJiBoYXNNb3JwaENvbG9yKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKCFoYXNNb3JwaFBvc2l0aW9uICYmICFoYXNNb3JwaE5vcm1hbCAmJiAhaGFzTW9ycGhDb2xvcilcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdlb21ldHJ5KTtcbiAgY29uc3QgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzID0gW107XG4gIGNvbnN0IHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ0NvbG9yQWNjZXNzb3JzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuUE9TSVRJT04pIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaE5vcm1hbCkge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0Lk5PUk1BTCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuTk9STUFMKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICAgICAgcGVuZGluZ05vcm1hbEFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaENvbG9yKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuQ09MT1JfMCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuQ09MT1JfMCkgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgcGVuZGluZ0NvbG9yQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdDb2xvckFjY2Vzc29ycylcbiAgXSkudGhlbihmdW5jdGlvbihhY2Nlc3NvcnMpIHtcbiAgICBjb25zdCBtb3JwaFBvc2l0aW9ucyA9IGFjY2Vzc29yc1swXTtcbiAgICBjb25zdCBtb3JwaE5vcm1hbHMgPSBhY2Nlc3NvcnNbMV07XG4gICAgY29uc3QgbW9ycGhDb2xvcnMgPSBhY2Nlc3NvcnNbMl07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcbiAgICBpZiAoaGFzTW9ycGhOb3JtYWwpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuICAgIGlmIChoYXNNb3JwaENvbG9yKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yID0gbW9ycGhDb2xvcnM7XG4gICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZikge1xuICBtZXNoLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuICBpZiAobWVzaERlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBtZXNoRGVmLndlaWdodHNbaV07XG4gICAgfVxuICB9XG4gIGlmIChtZXNoRGVmLmV4dHJhcyAmJiBBcnJheS5pc0FycmF5KG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzKSkge1xuICAgIGNvbnN0IHRhcmdldE5hbWVzID0gbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXM7XG4gICAgaWYgKG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCA9PT0gdGFyZ2V0TmFtZXMubGVuZ3RoKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVt0YXJnZXROYW1lc1tpXV0gPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJbnZhbGlkIGV4dHJhcy50YXJnZXROYW1lcyBsZW5ndGguIElnbm9yaW5nIG5hbWVzLlwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmVEZWYpIHtcbiAgbGV0IGdlb21ldHJ5S2V5O1xuICBjb25zdCBkcmFjb0V4dGVuc2lvbiA9IHByaW1pdGl2ZURlZi5leHRlbnNpb25zICYmIHByaW1pdGl2ZURlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dO1xuICBpZiAoZHJhY29FeHRlbnNpb24pIHtcbiAgICBnZW9tZXRyeUtleSA9IFwiZHJhY286XCIgKyBkcmFjb0V4dGVuc2lvbi5idWZmZXJWaWV3ICsgXCI6XCIgKyBkcmFjb0V4dGVuc2lvbi5pbmRpY2VzICsgXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KGRyYWNvRXh0ZW5zaW9uLmF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGdlb21ldHJ5S2V5ID0gcHJpbWl0aXZlRGVmLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkocHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXMpICsgXCI6XCIgKyBwcmltaXRpdmVEZWYubW9kZTtcbiAgfVxuICBpZiAocHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZURlZi50YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5S2V5ICs9IFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYudGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9tZXRyeUtleTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoYXR0cmlidXRlcykge1xuICBsZXQgYXR0cmlidXRlc0tleSA9IFwiXCI7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zb3J0KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGF0dHJpYnV0ZXNLZXkgKz0ga2V5c1tpXSArIFwiOlwiICsgYXR0cmlidXRlc1trZXlzW2ldXSArIFwiO1wiO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzS2V5O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKGNvbnN0cnVjdG9yKSB7XG4gIHN3aXRjaCAoY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMTI3O1xuICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMjU1O1xuICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMzI3Njc7XG4gICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gNjU1MzU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIG5vcm1hbGl6ZWQgYWNjZXNzb3IgY29tcG9uZW50IHR5cGUuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVVSSU1pbWVUeXBlKHVyaSkge1xuICBpZiAodXJpLnNlYXJjaCgvXFwuanBlP2coJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvanBlZy8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL2pwZWdcIjtcbiAgaWYgKHVyaS5zZWFyY2goL1xcLndlYnAoJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvd2VicC8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL3dlYnBcIjtcbiAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XG59XG5jb25zdCBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuY2xhc3MgR0xURlBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGpzb24gPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgR0xURlJlZ2lzdHJ5KCk7XG4gICAgdGhpcy5hc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJpbWl0aXZlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMubWVzaENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmNhbWVyYUNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmxpZ2h0Q2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuc291cmNlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZU5hbWVzVXNlZCA9IHt9O1xuICAgIGxldCBpc1NhZmFyaSA9IGZhbHNlO1xuICAgIGxldCBpc0ZpcmVmb3ggPSBmYWxzZTtcbiAgICBsZXQgZmlyZWZveFZlcnNpb24gPSAtMTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID09PSB0cnVlO1xuICAgICAgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xO1xuICAgICAgZmlyZWZveFZlcnNpb24gPSBpc0ZpcmVmb3ggPyBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFswLTldKylcXC4vKVsxXSA6IC0xO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSBcInVuZGVmaW5lZFwiIHx8IGlzU2FmYXJpIHx8IGlzRmlyZWZveCAmJiBmaXJlZm94VmVyc2lvbiA8IDk4KSB7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBJbWFnZUJpdG1hcExvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgdGhpcy5maWxlTG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IFwidXNlLWNyZWRlbnRpYWxzXCIpIHtcbiAgICAgIHRoaXMuZmlsZUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gIH1cbiAgc2V0UGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2lucztcbiAgfVxuICBwYXJzZShvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICB0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5fbWFya0RlZnMgJiYgZXh0Ll9tYXJrRGVmcygpO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmJlZm9yZVJvb3QgJiYgZXh0LmJlZm9yZVJvb3QoKTtcbiAgICAgIH0pXG4gICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcInNjZW5lXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiYW5pbWF0aW9uXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiY2FtZXJhXCIpXG4gICAgICBdKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzY2VuZTogZGVwZW5kZW5jaWVzWzBdW2pzb24uc2NlbmUgfHwgMF0sXG4gICAgICAgIHNjZW5lczogZGVwZW5kZW5jaWVzWzBdLFxuICAgICAgICBhbmltYXRpb25zOiBkZXBlbmRlbmNpZXNbMV0sXG4gICAgICAgIGNhbWVyYXM6IGRlcGVuZGVuY2llc1syXSxcbiAgICAgICAgYXNzZXQ6IGpzb24uYXNzZXQsXG4gICAgICAgIHBhcnNlcixcbiAgICAgICAgdXNlckRhdGE6IHt9XG4gICAgICB9O1xuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHJlc3VsdCwganNvbik7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHJlc3VsdCwganNvbik7XG4gICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGV4dC5hZnRlclJvb3QgJiYgZXh0LmFmdGVyUm9vdChyZXN1bHQpO1xuICAgICAgICB9KVxuICAgICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKG9uRXJyb3IpO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrcyB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlLlxuICAgKi9cbiAgX21hcmtEZWZzKCkge1xuICAgIGNvbnN0IG5vZGVEZWZzID0gdGhpcy5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuICAgIGNvbnN0IG1lc2hEZWZzID0gdGhpcy5qc29uLm1lc2hlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9pbnRzID0gc2tpbkRlZnNbc2tpbkluZGV4XS5qb2ludHM7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlRGVmc1tqb2ludHNbaV1dLmlzQm9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLm1lc2ggIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMubWVzaENhY2hlLCBub2RlRGVmLm1lc2gpO1xuICAgICAgICBpZiAobm9kZURlZi5za2luICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoRGVmc1tub2RlRGVmLm1lc2hdLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyByZWZlcmVuY2VzIHRvIHNoYXJlZCBub2RlIC8gT2JqZWN0M0QgcmVzb3VyY2VzLiBUaGVzZSByZXNvdXJjZXNcbiAgICogY2FuIGJlIHJldXNlZCwgb3IgXCJpbnN0YW50aWF0ZWRcIiwgYXQgbXVsdGlwbGUgbm9kZXMgaW4gdGhlIHNjZW5lXG4gICAqIGhpZXJhcmNoeS4gTWVzaCwgQ2FtZXJhLCBhbmQgTGlnaHQgaW5zdGFuY2VzIGFyZSBpbnN0YW50aWF0ZWQgYW5kIG11c3RcbiAgICogYmUgbWFya2VkLiBOb24tc2NlbmVncmFwaCByZXNvdXJjZXMgKGxpa2UgTWF0ZXJpYWxzLCBHZW9tZXRyaWVzLCBhbmRcbiAgICogVGV4dHVyZXMpIGNhbiBiZSByZXVzZWQgZGlyZWN0bHkgYW5kIGFyZSBub3QgbWFya2VkIGhlcmUuXG4gICAqXG4gICAqIEV4YW1wbGU6IENlc2l1bU1pbGtUcnVjayBzYW1wbGUgbW9kZWwgcmV1c2VzIFwiV2hlZWxcIiBtZXNoZXMuXG4gICAqL1xuICBfYWRkTm9kZVJlZihjYWNoZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY2FjaGUucmVmc1tpbmRleF0gPT09IHZvaWQgMCkge1xuICAgICAgY2FjaGUucmVmc1tpbmRleF0gPSBjYWNoZS51c2VzW2luZGV4XSA9IDA7XG4gICAgfVxuICAgIGNhY2hlLnJlZnNbaW5kZXhdKys7XG4gIH1cbiAgLyoqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgcmVzb3VyY2UsIGNsb25pbmcgaXQgaWYgbmVjZXNzYXJ5LiAqL1xuICBfZ2V0Tm9kZVJlZihjYWNoZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA8PSAxKVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICBjb25zdCByZWYgPSBvYmplY3QuY2xvbmUoKTtcbiAgICBjb25zdCB1cGRhdGVNYXBwaW5ncyA9IChvcmlnaW5hbCwgY2xvbmUpID0+IHtcbiAgICAgIGNvbnN0IG1hcHBpbmdzID0gdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG9yaWdpbmFsKTtcbiAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjbG9uZSwgbWFwcGluZ3MpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbaSwgY2hpbGRdIG9mIG9yaWdpbmFsLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICB1cGRhdGVNYXBwaW5ncyhjaGlsZCwgY2xvbmUuY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlTWFwcGluZ3Mob2JqZWN0LCByZWYpO1xuICAgIHJlZi5uYW1lICs9IFwiX2luc3RhbmNlX1wiICsgY2FjaGUudXNlc1tpbmRleF0rKztcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIF9pbnZva2VPbmUoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy5wdXNoKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9pbnZva2VBbGwoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy51bnNoaWZ0KHRoaXMpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoZXh0ZW5zaW9uc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICBwZW5kaW5nLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSBzcGVjaWZpZWQgZGVwZW5kZW5jeSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRHxNYXRlcmlhbHxUSFJFRS5UZXh0dXJlfEFuaW1hdGlvbkNsaXB8QXJyYXlCdWZmZXJ8T2JqZWN0Pn1cbiAgICovXG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IHR5cGUgKyBcIjpcIiArIGluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzY2VuZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE5vZGUgJiYgZXh0LmxvYWROb2RlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc2hcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWVzaCAmJiBleHQubG9hZE1lc2goaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWNjZXNzb3JcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQWNjZXNzb3IoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnVmZmVyVmlld1wiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRCdWZmZXJWaWV3ICYmIGV4dC5sb2FkQnVmZmVyVmlldyhpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQnVmZmVyKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hdGVyaWFsXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE1hdGVyaWFsICYmIGV4dC5sb2FkTWF0ZXJpYWwoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dHVyZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRUZXh0dXJlICYmIGV4dC5sb2FkVGV4dHVyZShpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJza2luXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNraW4oaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYW5pbWF0aW9uXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEFuaW1hdGlvbiAmJiBleHQubG9hZEFuaW1hdGlvbihpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYW1lcmFcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQ2FtZXJhKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dCAhPSB0aGlzICYmIGV4dC5nZXREZXBlbmRlbmN5ICYmIGV4dC5nZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE9iamVjdD4+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jaWVzKHR5cGUpIHtcbiAgICBsZXQgZGVwZW5kZW5jaWVzID0gdGhpcy5jYWNoZS5nZXQodHlwZSk7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgICBjb25zdCBkZWZzID0gdGhpcy5qc29uW3R5cGUgKyAodHlwZSA9PT0gXCJtZXNoXCIgPyBcImVzXCIgOiBcInNcIildIHx8IFtdO1xuICAgICAgZGVwZW5kZW5jaWVzID0gUHJvbWlzZS5hbGwoXG4gICAgICAgIGRlZnMubWFwKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FjaGUuYWRkKHR5cGUsIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGxvYWRCdWZmZXIoYnVmZmVySW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1tidWZmZXJJbmRleF07XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5maWxlTG9hZGVyO1xuICAgIGlmIChidWZmZXJEZWYudHlwZSAmJiBidWZmZXJEZWYudHlwZSAhPT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBcIiArIGJ1ZmZlckRlZi50eXBlICsgXCIgYnVmZmVyIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGlmIChidWZmZXJEZWYudXJpID09PSB2b2lkIDAgJiYgYnVmZmVySW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5ib2R5KTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBsb2FkZXIubG9hZChMb2FkZXJVdGlscy5yZXNvbHZlVVJMKGJ1ZmZlckRlZi51cmksIG9wdGlvbnMucGF0aCksIHJlc29sdmUsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IEZhaWxlZCB0byBsb2FkIGJ1ZmZlciBcIicgKyBidWZmZXJEZWYudXJpICsgJ1wiLicpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVmlld0luZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlclZpZXcoYnVmZmVyVmlld0luZGV4KSB7XG4gICAgY29uc3QgYnVmZmVyVmlld0RlZiA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1tidWZmZXJWaWV3SW5kZXhdO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgYnVmZmVyVmlld0RlZi5idWZmZXIpLnRoZW4oZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuICAgKi9cbiAgbG9hZEFjY2Vzc29yKGFjY2Vzc29ySW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzW2FjY2Vzc29ySW5kZXhdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ID09PSB2b2lkIDAgJiYgYWNjZXNzb3JEZWYuc3BhcnNlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdCdWZmZXJWaWV3cyA9IFtdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuYnVmZmVyVmlldykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaChudWxsKTtcbiAgICB9XG4gICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXcpKTtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3KSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nQnVmZmVyVmlld3MpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlld3MpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1swXTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBlbGVtZW50Qnl0ZXMgPSBUeXBlZEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgY29uc3QgaXRlbUJ5dGVzID0gZWxlbWVudEJ5dGVzICogaXRlbVNpemU7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYWNjZXNzb3JEZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgY29uc3QgYnl0ZVN0cmlkZSA9IGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCA/IGpzb24uYnVmZmVyVmlld3NbYWNjZXNzb3JEZWYuYnVmZmVyVmlld10uYnl0ZVN0cmlkZSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgbGV0IGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG4gICAgICBpZiAoYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgaWJTbGljZSA9IE1hdGguZmxvb3IoYnl0ZU9mZnNldCAvIGJ5dGVTdHJpZGUpO1xuICAgICAgICBjb25zdCBpYkNhY2hlS2V5ID0gXCJJbnRlcmxlYXZlZEJ1ZmZlcjpcIiArIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgKyBcIjpcIiArIGliU2xpY2UgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvdW50O1xuICAgICAgICBsZXQgaWIgPSBwYXJzZXIuY2FjaGUuZ2V0KGliQ2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWliKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3LCBpYlNsaWNlICogYnl0ZVN0cmlkZSwgYWNjZXNzb3JEZWYuY291bnQgKiBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyk7XG4gICAgICAgICAgcGFyc2VyLmNhY2hlLmFkZChpYkNhY2hlS2V5LCBpYik7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgIGliLFxuICAgICAgICAgIGl0ZW1TaXplLFxuICAgICAgICAgIGJ5dGVPZmZzZXQgJSBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzLFxuICAgICAgICAgIG5vcm1hbGl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ID09PSBudWxsKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGJ5dGVPZmZzZXQsIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBpdGVtU2l6ZUluZGljZXMgPSBXRUJHTF9UWVBFX1NJWkVTLlNDQUxBUjtcbiAgICAgICAgY29uc3QgVHlwZWRBcnJheUluZGljZXMgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuY29tcG9uZW50VHlwZV07XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRJbmRpY2VzID0gYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0VmFsdWVzID0gYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNwYXJzZUluZGljZXMgPSBuZXcgVHlwZWRBcnJheUluZGljZXMoXG4gICAgICAgICAgYnVmZmVyVmlld3NbMV0sXG4gICAgICAgICAgYnl0ZU9mZnNldEluZGljZXMsXG4gICAgICAgICAgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXdzWzJdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zbGljZSgpLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLml0ZW1TaXplLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNwYXJzZUluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3BhcnNlSW5kaWNlc1tpXTtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WChpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZV0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSAyKVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFkoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAxXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDMpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WihpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDJdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gNClcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRXKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgM10pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCN0ZXh0dXJlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gdGV4dHVyZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuVGV4dHVyZXxudWxsPn1cbiAgICovXG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZUluZGV4ID0gdGV4dHVyZURlZi5zb3VyY2U7XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZURlZi51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2VEZWYudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcik7XG4gIH1cbiAgbG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgY2FjaGVLZXkgPSAoc291cmNlRGVmLnVyaSB8fCBzb3VyY2VEZWYuYnVmZmVyVmlldykgKyBcIjpcIiArIHRleHR1cmVEZWYuc2FtcGxlcjtcbiAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5sb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICB0ZXh0dXJlLm5hbWUgPSB0ZXh0dXJlRGVmLm5hbWUgfHwgc291cmNlRGVmLm5hbWUgfHwgXCJcIjtcbiAgICAgIGlmICh0ZXh0dXJlLm5hbWUgPT09IFwiXCIgJiYgdHlwZW9mIHNvdXJjZURlZi51cmkgPT09IFwic3RyaW5nXCIgJiYgc291cmNlRGVmLnVyaS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9cIikgPT09IGZhbHNlKSB7XG4gICAgICAgIHRleHR1cmUubmFtZSA9IHNvdXJjZURlZi51cmk7XG4gICAgICB9XG4gICAgICBjb25zdCBzYW1wbGVycyA9IGpzb24uc2FtcGxlcnMgfHwge307XG4gICAgICBjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbdGV4dHVyZURlZi5zYW1wbGVyXSB8fCB7fTtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gV0VCR0xfRklMVEVSU1tzYW1wbGVyLm1hZ0ZpbHRlcl0gfHwgTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWluRmlsdGVyXSB8fCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLndyYXBTID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFNdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS53cmFwVCA9IFdFQkdMX1dSQVBQSU5HU1tzYW1wbGVyLndyYXBUXSB8fCBSZXBlYXRXcmFwcGluZztcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIHsgdGV4dHVyZXM6IHRleHR1cmVJbmRleCB9KTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBsb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0udGhlbigodGV4dHVyZSkgPT4gdGV4dHVyZS5jbG9uZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGNvbnN0IFVSTCA9IHNlbGYuVVJMIHx8IHNlbGYud2Via2l0VVJMO1xuICAgIGxldCBzb3VyY2VVUkkgPSBzb3VyY2VEZWYudXJpIHx8IFwiXCI7XG4gICAgbGV0IGlzT2JqZWN0VVJMID0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZURlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBzb3VyY2VEZWYuYnVmZmVyVmlldykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICAgIGlzT2JqZWN0VVJMID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJWaWV3XSwgeyB0eXBlOiBzb3VyY2VEZWYubWltZVR5cGUgfSk7XG4gICAgICAgIHNvdXJjZVVSSSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiBzb3VyY2VVUkk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZURlZi51cmkgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgXCIgKyBzb3VyY2VJbmRleCArIFwiIGlzIG1pc3NpbmcgVVJJIGFuZCBidWZmZXJWaWV3XCIpO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHNvdXJjZVVSSSkudGhlbihmdW5jdGlvbihzb3VyY2VVUkkyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBvbkxvYWQgPSByZXNvbHZlO1xuICAgICAgICBpZiAobG9hZGVyLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBvbkxvYWQgPSBmdW5jdGlvbihpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlQml0bWFwKTtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoc291cmNlVVJJMiwgb3B0aW9ucy5wYXRoKSwgb25Mb2FkLCB2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmIChpc09iamVjdFVSTCA9PT0gdHJ1ZSkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNvdXJjZVVSSSk7XG4gICAgICB9XG4gICAgICB0ZXh0dXJlLnVzZXJEYXRhLm1pbWVUeXBlID0gc291cmNlRGVmLm1pbWVUeXBlIHx8IGdldEltYWdlVVJJTWltZVR5cGUoc291cmNlRGVmLnVyaSk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IENvdWxkbid0IGxvYWQgdGV4dHVyZVwiLCBzb3VyY2VVUkkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBhc3NpZ25zIGEgdGV4dHVyZSB0byB0aGUgZ2l2ZW4gbWF0ZXJpYWwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsUGFyYW1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcbiAgICogQHJldHVybiB7UHJvbWlzZTxUZXh0dXJlPn1cbiAgICovXG4gIGFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIG1hcE5hbWUsIG1hcERlZiwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJ0ZXh0dXJlXCIsIG1hcERlZi5pbmRleCkudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICBpZiAoIXRleHR1cmUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKG1hcERlZi50ZXhDb29yZCAhPT0gdm9pZCAwICYmIG1hcERlZi50ZXhDb29yZCA+IDApIHtcbiAgICAgICAgdGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcbiAgICAgICAgdGV4dHVyZS5jaGFubmVsID0gbWFwRGVmLnRleENvb3JkO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBtYXBEZWYuZXh0ZW5zaW9ucyAhPT0gdm9pZCAwID8gbWFwRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dIDogdm9pZCAwO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgZ2x0ZlJlZmVyZW5jZSA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KHRleHR1cmUpO1xuICAgICAgICAgIHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0uZXh0ZW5kVGV4dHVyZSh0ZXh0dXJlLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIGdsdGZSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoXCJjb2xvclNwYWNlXCIgaW4gdGV4dHVyZSlcbiAgICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBlbmNvZGluZyA9PT0gMzAwMSA/IFwic3JnYlwiIDogXCJzcmdiLWxpbmVhclwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXNbbWFwTmFtZV0gPSB0ZXh0dXJlO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbnMgZmluYWwgbWF0ZXJpYWwgdG8gYSBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuIFRoZSBpbnN0YW5jZVxuICAgKiBhbHJlYWR5IGhhcyBhIG1hdGVyaWFsIChnZW5lcmF0ZWQgZnJvbSB0aGUgZ2xURiBtYXRlcmlhbCBvcHRpb25zIGFsb25lKVxuICAgKiBidXQgcmV1c2Ugb2YgdGhlIHNhbWUgZ2xURiBtYXRlcmlhbCBtYXkgcmVxdWlyZSBtdWx0aXBsZSB0aHJlZWpzIG1hdGVyaWFsc1xuICAgKiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgcHJpbWl0aXZlIHR5cGVzLCBkZWZpbmVzLCBldGMuIE5ldyBtYXRlcmlhbHMgd2lsbFxuICAgKiBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSwgYW5kIHJldXNlZCBmcm9tIGEgY2FjaGUuXG4gICAqIEBwYXJhbSAge09iamVjdDNEfSBtZXNoIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS5cbiAgICovXG4gIGFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcbiAgICBsZXQgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuICAgIGNvbnN0IHVzZURlcml2YXRpdmVUYW5nZW50cyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZVZlcnRleENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VGbGF0U2hhZGluZyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsID09PSB2b2lkIDA7XG4gICAgaWYgKG1lc2guaXNQb2ludHMpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJQb2ludHNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgcG9pbnRzTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIXBvaW50c01hdGVyaWFsKSB7XG4gICAgICAgIHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwocG9pbnRzTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHNNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IHBvaW50c01hdGVyaWFsO1xuICAgIH0gZWxzZSBpZiAobWVzaC5pc0xpbmUpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJMaW5lQmFzaWNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgbGluZU1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFsaW5lTWF0ZXJpYWwpIHtcbiAgICAgICAgbGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwobGluZU1hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGxpbmVNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGxpbmVNYXRlcmlhbDtcbiAgICB9XG4gICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cyB8fCB1c2VWZXJ0ZXhDb2xvcnMgfHwgdXNlRmxhdFNoYWRpbmcpIHtcbiAgICAgIGxldCBjYWNoZUtleSA9IFwiQ2xvbmVkTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkICsgXCI6XCI7XG4gICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKVxuICAgICAgICBjYWNoZUtleSArPSBcImRlcml2YXRpdmUtdGFuZ2VudHM6XCI7XG4gICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICBjYWNoZUtleSArPSBcInZlcnRleC1jb2xvcnM6XCI7XG4gICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZmxhdC1zaGFkaW5nOlwiO1xuICAgICAgbGV0IGNhY2hlZE1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFjYWNoZWRNYXRlcmlhbCkge1xuICAgICAgICBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cykge1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgY2FjaGVkTWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9ucy5zZXQoY2FjaGVkTWF0ZXJpYWwsIHRoaXMuYXNzb2NpYXRpb25zLmdldChtYXRlcmlhbCkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcbiAgICB9XG4gICAgbWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZSgpIHtcbiAgICByZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWF0ZXJpYWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXRlcmlhbEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWF0ZXJpYWw+fVxuICAgKi9cbiAgbG9hZE1hdGVyaWFsKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IGpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGxldCBtYXRlcmlhbFR5cGU7XG4gICAgY29uc3QgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcbiAgICBjb25zdCBtYXRlcmlhbEV4dGVuc2lvbnMgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBpZiAobWF0ZXJpYWxFeHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF0pIHtcbiAgICAgIGNvbnN0IGttdUV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXTtcbiAgICAgIG1hdGVyaWFsVHlwZSA9IGttdUV4dGVuc2lvbi5nZXRNYXRlcmlhbFR5cGUoKTtcbiAgICAgIHBlbmRpbmcucHVzaChrbXVFeHRlbnNpb24uZXh0ZW5kUGFyYW1zKG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KGFycmF5KTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIDMwMDEpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zLm1ldGFsbmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yICE9PSB2b2lkIDAgPyBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA6IDE7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDE7XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1ldGFsbmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInJvdWdobmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsVHlwZSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4dC5nZXRNYXRlcmlhbFR5cGUgJiYgZXh0LmdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zICYmIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmRvdWJsZVNpZGVkID09PSB0cnVlKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaWRlID0gRG91YmxlU2lkZTtcbiAgICB9XG4gICAgY29uc3QgYWxwaGFNb2RlID0gbWF0ZXJpYWxEZWYuYWxwaGFNb2RlIHx8IEFMUEhBX01PREVTLk9QQVFVRTtcbiAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5CTEVORCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuTUFTSykge1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5hbHBoYVRlc3QgPSBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiAhPT0gdm9pZCAwID8gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgOiAwLjU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm5vcm1hbE1hcFwiLCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlKSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGU7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldChzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJhb01hcFwiLCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlKSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFvTWFwSW50ZW5zaXR5ID0gbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkobWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IpO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImVtaXNzaXZlTWFwXCIsIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSwgMzAwMSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IG1hdGVyaWFsVHlwZShtYXRlcmlhbFBhcmFtcyk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubmFtZSlcbiAgICAgICAgbWF0ZXJpYWwubmFtZSA9IG1hdGVyaWFsRGVmLm5hbWU7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtYXRlcmlhbCwgeyBtYXRlcmlhbHM6IG1hdGVyaWFsSW5kZXggfSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICByZXR1cm4gbWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgLyoqIFdoZW4gT2JqZWN0M0QgaW5zdGFuY2VzIGFyZSB0YXJnZXRlZCBieSBhbmltYXRpb24sIHRoZXkgbmVlZCB1bmlxdWUgbmFtZXMuICovXG4gIGNyZWF0ZVVuaXF1ZU5hbWUob3JpZ2luYWxOYW1lKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKG9yaWdpbmFsTmFtZSB8fCBcIlwiKTtcbiAgICBpZiAoc2FuaXRpemVkTmFtZSBpbiB0aGlzLm5vZGVOYW1lc1VzZWQpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lICsgXCJfXCIgKyArK3RoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdID0gMDtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNnZW9tZXRyeVxuICAgKlxuICAgKiBDcmVhdGVzIEJ1ZmZlckdlb21ldHJpZXMgZnJvbSBwcmltaXRpdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEdMVEYuUHJpbWl0aXZlPn0gcHJpbWl0aXZlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEJ1ZmZlckdlb21ldHJ5Pj59XG4gICAqL1xuICBsb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wcmltaXRpdmVDYWNoZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dLmRlY29kZVByaW1pdGl2ZShwcmltaXRpdmUsIHBhcnNlcikudGhlbihmdW5jdGlvbihnZW9tZXRyeSkge1xuICAgICAgICByZXR1cm4gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhnZW9tZXRyeSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmUpO1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBwZW5kaW5nLnB1c2goY2FjaGVkLnByb21pc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGdlb21ldHJ5UHJvbWlzZTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zICYmIHByaW1pdGl2ZS5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dKSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVbY2FjaGVLZXldID0geyBwcmltaXRpdmUsIHByb21pc2U6IGdlb21ldHJ5UHJvbWlzZSB9O1xuICAgICAgICBwZW5kaW5nLnB1c2goZ2VvbWV0cnlQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21lc2hlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWVzaEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXB8TWVzaHxTa2lubmVkTWVzaD59XG4gICAqL1xuICBsb2FkTWVzaChtZXNoSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbbWVzaEluZGV4XTtcbiAgICBjb25zdCBwcmltaXRpdmVzID0gbWVzaERlZi5wcmltaXRpdmVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCA9PT0gdm9pZCAwID8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKHRoaXMuY2FjaGUpIDogdGhpcy5nZXREZXBlbmRlbmN5KFwibWF0ZXJpYWxcIiwgcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCk7XG4gICAgICBwZW5kaW5nLnB1c2gobWF0ZXJpYWwpO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSByZXN1bHRzLnNsaWNlKDAsIHJlc3VsdHMubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbWVzaGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgICBsZXQgbWVzaDtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbaV07XG4gICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOIHx8IHByaW1pdGl2ZS5tb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoID0gbWVzaERlZi5pc1NraW5uZWRNZXNoID09PSB0cnVlID8gbmV3IFNraW5uZWRNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCkgOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgIGlmIChtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lc2gubm9ybWFsaXplU2tpbldlaWdodHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVApIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTikge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVGYW5EcmF3TW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORVMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVTZWdtZW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9TVFJJUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9MT09QKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lTG9vcChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuUE9JTlRTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBQb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogXCIgKyBwcmltaXRpdmUubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXBkYXRlTW9ycGhUYXJnZXRzKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICB9XG4gICAgICAgIG1lc2gubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG1lc2hEZWYubmFtZSB8fCBcIm1lc2hfXCIgKyBtZXNoSW5kZXgpO1xuICAgICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2gsIHByaW1pdGl2ZSk7XG4gICAgICAgIHBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpO1xuICAgICAgICBtZXNoZXMucHVzaChtZXNoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1lc2hlc1tpXSwge1xuICAgICAgICAgIG1lc2hlczogbWVzaEluZGV4LFxuICAgICAgICAgIHByaW1pdGl2ZXM6IGlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoZXNbMF0sIG1lc2hEZWYpO1xuICAgICAgICByZXR1cm4gbWVzaGVzWzBdO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBncm91cCwgbWVzaERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChncm91cCwgeyBtZXNoZXM6IG1lc2hJbmRleCB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwLmFkZChtZXNoZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjY2FtZXJhc1xuICAgKiBAcGFyYW0ge251bWJlcn0gY2FtZXJhSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5DYW1lcmE+fVxuICAgKi9cbiAgbG9hZENhbWVyYShjYW1lcmFJbmRleCkge1xuICAgIGxldCBjYW1lcmE7XG4gICAgY29uc3QgY2FtZXJhRGVmID0gdGhpcy5qc29uLmNhbWVyYXNbY2FtZXJhSW5kZXhdO1xuICAgIGNvbnN0IHBhcmFtcyA9IGNhbWVyYURlZltjYW1lcmFEZWYudHlwZV07XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgY2FtZXJhIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwicGVyc3BlY3RpdmVcIikge1xuICAgICAgY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKFxuICAgICAgICBNYXRoVXRpbHMucmFkVG9EZWcocGFyYW1zLnlmb3YpLFxuICAgICAgICBwYXJhbXMuYXNwZWN0UmF0aW8gfHwgMSxcbiAgICAgICAgcGFyYW1zLnpuZWFyIHx8IDEsXG4gICAgICAgIHBhcmFtcy56ZmFyIHx8IDJlNlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNhbWVyYURlZi50eXBlID09PSBcIm9ydGhvZ3JhcGhpY1wiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKC1wYXJhbXMueG1hZywgcGFyYW1zLnhtYWcsIHBhcmFtcy55bWFnLCAtcGFyYW1zLnltYWcsIHBhcmFtcy56bmVhciwgcGFyYW1zLnpmYXIpO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLm5hbWUpXG4gICAgICBjYW1lcmEubmFtZSA9IHRoaXMuY3JlYXRlVW5pcXVlTmFtZShjYW1lcmFEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShjYW1lcmEsIGNhbWVyYURlZik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNraW5JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFNrZWxldG9uPn1cbiAgICovXG4gIGxvYWRTa2luKHNraW5JbmRleCkge1xuICAgIGNvbnN0IHNraW5EZWYgPSB0aGlzLmpzb24uc2tpbnNbc2tpbkluZGV4XTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc2tpbkRlZi5qb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuX2xvYWROb2RlU2hhbGxvdyhza2luRGVmLmpvaW50c1tpXSkpO1xuICAgIH1cbiAgICBpZiAoc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBpbnZlcnNlQmluZE1hdHJpY2VzID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IGpvaW50Tm9kZXMgPSByZXN1bHRzO1xuICAgICAgY29uc3QgYm9uZXMgPSBbXTtcbiAgICAgIGNvbnN0IGJvbmVJbnZlcnNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gam9pbnROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGpvaW50Tm9kZSA9IGpvaW50Tm9kZXNbaV07XG4gICAgICAgIGlmIChqb2ludE5vZGUpIHtcbiAgICAgICAgICBib25lcy5wdXNoKGpvaW50Tm9kZSk7XG4gICAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgICBpZiAoaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF0LmZyb21BcnJheShpbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBpICogMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib25lSW52ZXJzZXMucHVzaChtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRGVmLmpvaW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2tlbGV0b24oYm9uZXMsIGJvbmVJbnZlcnNlcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNhbmltYXRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFuaW1hdGlvbkNsaXA+fVxuICAgKi9cbiAgbG9hZEFuaW1hdGlvbihhbmltYXRpb25JbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zW2FuaW1hdGlvbkluZGV4XTtcbiAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYW5pbWF0aW9uRGVmLm5hbWUgPyBhbmltYXRpb25EZWYubmFtZSA6IFwiYW5pbWF0aW9uX1wiICsgYW5pbWF0aW9uSW5kZXg7XG4gICAgY29uc3QgcGVuZGluZ05vZGVzID0gW107XG4gICAgY29uc3QgcGVuZGluZ0lucHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdTYW1wbGVycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdUYXJnZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHNbaV07XG4gICAgICBjb25zdCBzYW1wbGVyID0gYW5pbWF0aW9uRGVmLnNhbXBsZXJzW2NoYW5uZWwuc2FtcGxlcl07XG4gICAgICBjb25zdCB0YXJnZXQgPSBjaGFubmVsLnRhcmdldDtcbiAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubm9kZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIuaW5wdXRdIDogc2FtcGxlci5pbnB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLm91dHB1dF0gOiBzYW1wbGVyLm91dHB1dDtcbiAgICAgIGlmICh0YXJnZXQubm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHBlbmRpbmdOb2Rlcy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbmFtZSkpO1xuICAgICAgcGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgaW5wdXQpKTtcbiAgICAgIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBvdXRwdXQpKTtcbiAgICAgIHBlbmRpbmdTYW1wbGVycy5wdXNoKHNhbXBsZXIpO1xuICAgICAgcGVuZGluZ1RhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ05vZGVzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdJbnB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nT3V0cHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdTYW1wbGVycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nVGFyZ2V0cylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3Qgbm9kZXMgPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICBjb25zdCBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sxXTtcbiAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1syXTtcbiAgICAgIGNvbnN0IHNhbXBsZXJzID0gZGVwZW5kZW5jaWVzWzNdO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1s0XTtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3IgPSBpbnB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgbGV0IFR5cGVkS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgc3dpdGNoIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdKSB7XG4gICAgICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0czpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5yb3RhdGlvbjpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMucG9zaXRpb246XG4gICAgICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMuc2NhbGU6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB2b2lkIDAgPyBJTlRFUlBPTEFUSU9OW3NhbXBsZXIuaW50ZXJwb2xhdGlvbl0gOiBJbnRlcnBvbGF0ZUxpbmVhcjtcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0gPT09IFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzKSB7XG4gICAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzKSB7XG4gICAgICAgICAgICAgIHRhcmdldE5hbWVzLnB1c2gob2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC51dWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXROYW1lcy5wdXNoKHRhcmdldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXRBcnJheSA9IG91dHB1dEFjY2Vzc29yLmFycmF5O1xuICAgICAgICBpZiAob3V0cHV0QWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKG91dHB1dEFycmF5LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICBjb25zdCBzY2FsZWQgPSBuZXcgRmxvYXQzMkFycmF5KG91dHB1dEFycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gb3V0cHV0QXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgc2NhbGVkW2pdID0gb3V0cHV0QXJyYXlbal0gKiBzY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0QXJyYXkgPSBzY2FsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gbmV3IFR5cGVkS2V5ZnJhbWVUcmFjayhcbiAgICAgICAgICAgIHRhcmdldE5hbWVzW2pdICsgXCIuXCIgKyBQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdLFxuICAgICAgICAgICAgaW5wdXRBY2Nlc3Nvci5hcnJheSxcbiAgICAgICAgICAgIG91dHB1dEFycmF5LFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHNhbXBsZXIuaW50ZXJwb2xhdGlvbiA9PT0gXCJDVUJJQ1NQTElORVwiKSB7XG4gICAgICAgICAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZShyZXN1bHQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhbnRUeXBlID0gdGhpcyBpbnN0YW5jZW9mIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID8gR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IDogR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgaW50ZXJwb2xhbnRUeXBlKHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpIC8gMywgcmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKGFuaW1hdGlvbk5hbWUsIHZvaWQgMCwgdHJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAobm9kZURlZi5tZXNoID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJtZXNoXCIsIG5vZGVEZWYubWVzaCkudGhlbihmdW5jdGlvbihtZXNoKSB7XG4gICAgICBjb25zdCBub2RlID0gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCwgbWVzaCk7XG4gICAgICBpZiAobm9kZURlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKCFvLmlzTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgby5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBub2RlRGVmLndlaWdodHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbm9kZXMtYW5kLWhpZXJhcmNoeVxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0Q+fVxuICAgKi9cbiAgbG9hZE5vZGUobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZVBlbmRpbmcgPSBwYXJzZXIuX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpO1xuICAgIGNvbnN0IGNoaWxkUGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuRGVmID0gbm9kZURlZi5jaGlsZHJlbiB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbkRlZi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjaGlsZFBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgY2hpbGRyZW5EZWZbaV0pKTtcbiAgICB9XG4gICAgY29uc3Qgc2tlbGV0b25QZW5kaW5nID0gbm9kZURlZi5za2luID09PSB2b2lkIDAgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcInNraW5cIiwgbm9kZURlZi5za2luKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW25vZGVQZW5kaW5nLCBQcm9taXNlLmFsbChjaGlsZFBlbmRpbmcpLCBza2VsZXRvblBlbmRpbmddKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSByZXN1bHRzWzBdO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSByZXN1bHRzWzFdO1xuICAgICAgY29uc3Qgc2tlbGV0b24gPSByZXN1bHRzWzJdO1xuICAgICAgaWYgKHNrZWxldG9uICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obWVzaCkge1xuICAgICAgICAgIGlmICghbWVzaC5pc1NraW5uZWRNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIG1lc2guYmluZChza2VsZXRvbiwgX2lkZW50aXR5TWF0cml4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYWRkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8vIC5fbG9hZE5vZGVTaGFsbG93KCkgcGFyc2VzIGEgc2luZ2xlIG5vZGUuXG4gIC8vIHNraW4gYW5kIGNoaWxkIG5vZGVzIGFyZSBjcmVhdGVkIGFuZCBhZGRlZCBpbiAubG9hZE5vZGUoKSAobm8gJ18nIHByZWZpeCkuXG4gIF9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlRGVmLm5hbWUgPyBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShub2RlRGVmLm5hbWUpIDogXCJcIjtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgbWVzaFByb21pc2UgPSBwYXJzZXIuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZU1lc2ggJiYgZXh0LmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCk7XG4gICAgfSk7XG4gICAgaWYgKG1lc2hQcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gobWVzaFByb21pc2UpO1xuICAgIH1cbiAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImNhbWVyYVwiLCBub2RlRGVmLmNhbWVyYSkudGhlbihmdW5jdGlvbihjYW1lcmEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEsIGNhbWVyYSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQgJiYgZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocHJvbWlzZSk7XG4gICAgfSk7XG4gICAgdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSA9IFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ob2JqZWN0cykge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBpZiAobm9kZURlZi5pc0JvbmUgPT09IHRydWUpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBCb25lKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICBub2RlID0gbmV3IEdyb3VwKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG5vZGUgPSBvYmplY3RzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5ldyBPYmplY3QzRCgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgIT09IG9iamVjdHNbMF0pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgbm9kZS5hZGQob2JqZWN0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLm5hbWUpIHtcbiAgICAgICAgbm9kZS51c2VyRGF0YS5uYW1lID0gbm9kZURlZi5uYW1lO1xuICAgICAgICBub2RlLm5hbWUgPSBub2RlTmFtZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5tYXRyaXggIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICBtYXRyaXguZnJvbUFycmF5KG5vZGVEZWYubWF0cml4KTtcbiAgICAgICAgbm9kZS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlRGVmLnRyYW5zbGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnBvc2l0aW9uLmZyb21BcnJheShub2RlRGVmLnRyYW5zbGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5xdWF0ZXJuaW9uLmZyb21BcnJheShub2RlRGVmLnJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5zY2FsZS5mcm9tQXJyYXkobm9kZURlZi5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VyLmFzc29jaWF0aW9ucy5oYXMobm9kZSkpIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobm9kZSwge30pO1xuICAgICAgfVxuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZSkubm9kZXMgPSBub2RlSW5kZXg7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cbiAgICovXG4gIGxvYWRTY2VuZShzY2VuZUluZGV4KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBzY2VuZURlZiA9IHRoaXMuanNvbi5zY2VuZXNbc2NlbmVJbmRleF07XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBHcm91cCgpO1xuICAgIGlmIChzY2VuZURlZi5uYW1lKVxuICAgICAgc2NlbmUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKHNjZW5lRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBpZiAoc2NlbmVEZWYuZXh0ZW5zaW9ucylcbiAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGNvbnN0IG5vZGVJZHMgPSBzY2VuZURlZi5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZUlkcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIG5vZGVJZHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgc2NlbmUuYWRkKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZHVjZUFzc29jaWF0aW9ucyA9IChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZHVjZWRBc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwYXJzZXIuYXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIE1hdGVyaWFsIHx8IGtleSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnRyYXZlcnNlKChub2RlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcHBpbmdzID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZTIpO1xuICAgICAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChub2RlMiwgbWFwcGluZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWR1Y2VkQXNzb2NpYXRpb25zO1xuICAgICAgfTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMgPSByZWR1Y2VBc3NvY2lhdGlvbnMoc2NlbmUpO1xuICAgICAgcmV0dXJuIHNjZW5lO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGJveCA9IG5ldyBCb3gzKCk7XG4gIGlmIChhdHRyaWJ1dGVzLlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1thdHRyaWJ1dGVzLlBPU0lUSU9OXTtcbiAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgYm94LnNldChuZXcgVmVjdG9yMyhtaW5bMF0sIG1pblsxXSwgbWluWzJdKSwgbmV3IFZlY3RvcjMobWF4WzBdLCBtYXhbMV0sIG1heFsyXSkpO1xuICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgYm94Lm1pbi5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgIGJveC5tYXgubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IHByaW1pdGl2ZURlZi50YXJnZXRzO1xuICBpZiAodGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbWF4RGlzcGxhY2VtZW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1t0YXJnZXQuUE9TSVRJT05dO1xuICAgICAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICAgICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmVjdG9yLnNldFgoTWF0aC5tYXgoTWF0aC5hYnMobWluWzBdKSwgTWF0aC5hYnMobWF4WzBdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRZKE1hdGgubWF4KE1hdGguYWJzKG1pblsxXSksIE1hdGguYWJzKG1heFsxXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WihNYXRoLm1heChNYXRoLmFicyhtaW5bMl0pLCBNYXRoLmFicyhtYXhbMl0pKSk7XG4gICAgICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgICAgICB2ZWN0b3IubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXhEaXNwbGFjZW1lbnQubWF4KHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBib3guZXhwYW5kQnlWZWN0b3IobWF4RGlzcGxhY2VtZW50KTtcbiAgfVxuICBnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcbiAgY29uc3Qgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICBib3guZ2V0Q2VudGVyKHNwaGVyZS5jZW50ZXIpO1xuICBzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKGJveC5tYXgpIC8gMjtcbiAgZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBzcGhlcmU7XG59XG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGFjY2Vzc29ySW5kZXgpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IpIHtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhY2Nlc3Nvcik7XG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBnbHRmQXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1tnbHRmQXR0cmlidXRlTmFtZV0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpXG4gICAgICBjb250aW51ZTtcbiAgICBwZW5kaW5nLnB1c2goYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYXR0cmlidXRlc1tnbHRmQXR0cmlidXRlTmFtZV0sIHRocmVlQXR0cmlidXRlTmFtZSkpO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYuaW5kaWNlcyAhPT0gdm9pZCAwICYmICFnZW9tZXRyeS5pbmRleCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBwcmltaXRpdmVEZWYuaW5kaWNlcykudGhlbihmdW5jdGlvbihhY2Nlc3NvcjIpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KGFjY2Vzc29yMik7XG4gICAgfSk7XG4gICAgcGVuZGluZy5wdXNoKGFjY2Vzc29yKTtcbiAgfVxuICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYpO1xuICBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcik7XG4gIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwID8gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyKSA6IGdlb21ldHJ5O1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEdMVEZMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFRGTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkxvYWRlciIsIkxvYWRlclV0aWxzIiwiRmlsZUxvYWRlciIsIkNvbG9yIiwiU3BvdExpZ2h0IiwiUG9pbnRMaWdodCIsIkRpcmVjdGlvbmFsTGlnaHQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiVmVjdG9yMiIsIk1hdHJpeDQiLCJWZWN0b3IzIiwiUXVhdGVybmlvbiIsIkluc3RhbmNlZE1lc2giLCJPYmplY3QzRCIsIlRleHR1cmVMb2FkZXIiLCJJbWFnZUJpdG1hcExvYWRlciIsIkJ1ZmZlckF0dHJpYnV0ZSIsIkludGVybGVhdmVkQnVmZmVyIiwiSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJMaW5lYXJGaWx0ZXIiLCJMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIiLCJSZXBlYXRXcmFwcGluZyIsIlBvaW50c01hdGVyaWFsIiwiTWF0ZXJpYWwiLCJMaW5lQmFzaWNNYXRlcmlhbCIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiRG91YmxlU2lkZSIsIlByb3BlcnR5QmluZGluZyIsIkJ1ZmZlckdlb21ldHJ5IiwiU2tpbm5lZE1lc2giLCJNZXNoIiwiVHJpYW5nbGVTdHJpcERyYXdNb2RlIiwiVHJpYW5nbGVGYW5EcmF3TW9kZSIsIkxpbmVTZWdtZW50cyIsIkxpbmUiLCJMaW5lTG9vcCIsIlBvaW50cyIsIkdyb3VwIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJNYXRoVXRpbHMiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJTa2VsZXRvbiIsIkludGVycG9sYXRlTGluZWFyIiwiQW5pbWF0aW9uQ2xpcCIsIkJvbmUiLCJOZWFyZXN0RmlsdGVyIiwiTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIiLCJMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIiwiTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIiwiSW50ZXJwb2xhdGVEaXNjcmV0ZSIsIkZyb250U2lkZSIsIlRleHR1cmUiLCJWZWN0b3JLZXlmcmFtZVRyYWNrIiwiUXVhdGVybmlvbktleWZyYW1lVHJhY2siLCJOdW1iZXJLZXlmcmFtZVRyYWNrIiwiQm94MyIsIlNwaGVyZSIsIkludGVycG9sYW50IiwidG9UcmlhbmdsZXNEcmF3TW9kZSIsInZlcnNpb24iLCJHTFRGTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwiZHJhY29Mb2FkZXIiLCJrdHgyTG9hZGVyIiwibWVzaG9wdERlY29kZXIiLCJwbHVnaW5DYWxsYmFja3MiLCJyZWdpc3RlciIsInBhcnNlciIsIkdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24iLCJHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24iLCJHTFRGTGlnaHRzRXh0ZW5zaW9uIiwiR0xURk1lc2hvcHRDb21wcmVzc2lvbiIsIkdMVEZNZXNoR3B1SW5zdGFuY2luZyIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsInNjb3BlIiwicmVzb3VyY2VQYXRoIiwicGF0aCIsImV4dHJhY3RVcmxCYXNlIiwiaXRlbVN0YXJ0IiwiX29uRXJyb3IiLCJlIiwiY29uc29sZSIsImVycm9yIiwiaXRlbUVycm9yIiwiaXRlbUVuZCIsImxvYWRlciIsInNldFBhdGgiLCJzZXRSZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVxdWVzdEhlYWRlciIsInNldFdpdGhDcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImRhdGEiLCJwYXJzZSIsImdsdGYiLCJzZXREUkFDT0xvYWRlciIsInNldEREU0xvYWRlciIsIkVycm9yIiwic2V0S1RYMkxvYWRlciIsInNldE1lc2hvcHREZWNvZGVyIiwiY2FsbGJhY2siLCJpbmRleE9mIiwicHVzaCIsInVucmVnaXN0ZXIiLCJzcGxpY2UiLCJqc29uIiwiZXh0ZW5zaW9ucyIsInBsdWdpbnMiLCJKU09OIiwiQXJyYXlCdWZmZXIiLCJtYWdpYyIsImRlY29kZVRleHQiLCJVaW50OEFycmF5Iiwic2xpY2UiLCJCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyIsIkVYVEVOU0lPTlMiLCJLSFJfQklOQVJZX0dMVEYiLCJHTFRGQmluYXJ5RXh0ZW5zaW9uIiwiY29udGVudCIsImFzc2V0IiwiR0xURlBhcnNlciIsImNyb3NzT3JpZ2luIiwiZmlsZUxvYWRlciIsImkiLCJsZW5ndGgiLCJwbHVnaW4iLCJuYW1lIiwiZXh0ZW5zaW9uc1VzZWQiLCJleHRlbnNpb25OYW1lIiwiZXh0ZW5zaW9uc1JlcXVpcmVkIiwiS0hSX01BVEVSSUFMU19VTkxJVCIsIkdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbiIsIktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OIiwiR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uIiwiS0hSX1RFWFRVUkVfVFJBTlNGT1JNIiwiR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24iLCJLSFJfTUVTSF9RVUFOVElaQVRJT04iLCJHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbiIsIndhcm4iLCJzZXRFeHRlbnNpb25zIiwic2V0UGx1Z2lucyIsInBhcnNlQXN5bmMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkdMVEZSZWdpc3RyeSIsIm9iamVjdHMiLCJnZXQiLCJrZXkiLCJhZGQiLCJvYmplY3QiLCJyZW1vdmUiLCJyZW1vdmVBbGwiLCJLSFJfTElHSFRTX1BVTkNUVUFMIiwiS0hSX01BVEVSSUFMU19DTEVBUkNPQVQiLCJLSFJfTUFURVJJQUxTX0lPUiIsIktIUl9NQVRFUklBTFNfU0hFRU4iLCJLSFJfTUFURVJJQUxTX1NQRUNVTEFSIiwiS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT04iLCJLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFIiwiS0hSX01BVEVSSUFMU19BTklTT1RST1BZIiwiS0hSX01BVEVSSUFMU19WT0xVTUUiLCJLSFJfVEVYVFVSRV9CQVNJU1UiLCJLSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIIiwiRVhUX1RFWFRVUkVfV0VCUCIsIkVYVF9URVhUVVJFX0FWSUYiLCJFWFRfTUVTSE9QVF9DT01QUkVTU0lPTiIsIkVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HIiwiY2FjaGUiLCJyZWZzIiwidXNlcyIsIl9tYXJrRGVmcyIsIm5vZGVEZWZzIiwibm9kZXMiLCJub2RlSW5kZXgiLCJub2RlTGVuZ3RoIiwibm9kZURlZiIsImxpZ2h0IiwiX2FkZE5vZGVSZWYiLCJfbG9hZExpZ2h0IiwibGlnaHRJbmRleCIsImNhY2hlS2V5IiwiZGVwZW5kZW5jeSIsImxpZ2h0RGVmcyIsImxpZ2h0cyIsImxpZ2h0RGVmIiwibGlnaHROb2RlIiwiY29sb3IiLCJmcm9tQXJyYXkiLCJyYW5nZSIsInR5cGUiLCJ0YXJnZXQiLCJwb3NpdGlvbiIsInNldCIsImRpc3RhbmNlIiwic3BvdCIsImlubmVyQ29uZUFuZ2xlIiwib3V0ZXJDb25lQW5nbGUiLCJNYXRoIiwiUEkiLCJhbmdsZSIsInBlbnVtYnJhIiwiZGVjYXkiLCJhc3NpZ25FeHRyYXNUb1VzZXJEYXRhIiwiaW50ZW5zaXR5IiwiY3JlYXRlVW5pcXVlTmFtZSIsImdldERlcGVuZGVuY3kiLCJpbmRleCIsImNyZWF0ZU5vZGVBdHRhY2htZW50Iiwic2VsZjIiLCJ0aGVuIiwiX2dldE5vZGVSZWYiLCJnZXRNYXRlcmlhbFR5cGUiLCJleHRlbmRQYXJhbXMiLCJtYXRlcmlhbFBhcmFtcyIsIm1hdGVyaWFsRGVmIiwicGVuZGluZyIsIm9wYWNpdHkiLCJtZXRhbGxpY1JvdWdobmVzcyIsInBick1ldGFsbGljUm91Z2huZXNzIiwiQXJyYXkiLCJpc0FycmF5IiwiYmFzZUNvbG9yRmFjdG9yIiwiYXJyYXkiLCJiYXNlQ29sb3JUZXh0dXJlIiwiYXNzaWduVGV4dHVyZSIsImFsbCIsImV4dGVuZE1hdGVyaWFsUGFyYW1zIiwibWF0ZXJpYWxJbmRleCIsIm1hdGVyaWFscyIsImVtaXNzaXZlU3RyZW5ndGgiLCJlbWlzc2l2ZUludGVuc2l0eSIsImV4dGVuc2lvbiIsImNsZWFyY29hdEZhY3RvciIsImNsZWFyY29hdCIsImNsZWFyY29hdFRleHR1cmUiLCJjbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IiLCJjbGVhcmNvYXRSb3VnaG5lc3MiLCJjbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlIiwiY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSIsInNjYWxlIiwiY2xlYXJjb2F0Tm9ybWFsU2NhbGUiLCJpcmlkZXNjZW5jZUZhY3RvciIsImlyaWRlc2NlbmNlIiwiaXJpZGVzY2VuY2VUZXh0dXJlIiwiaXJpZGVzY2VuY2VJb3IiLCJpcmlkZXNjZW5jZUlPUiIsImlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UiLCJpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0iLCJpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0iLCJpcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUiLCJzaGVlbkNvbG9yIiwic2hlZW5Sb3VnaG5lc3MiLCJzaGVlbiIsInNoZWVuQ29sb3JGYWN0b3IiLCJzaGVlblJvdWdobmVzc0ZhY3RvciIsInNoZWVuQ29sb3JUZXh0dXJlIiwic2hlZW5Sb3VnaG5lc3NUZXh0dXJlIiwidHJhbnNtaXNzaW9uRmFjdG9yIiwidHJhbnNtaXNzaW9uIiwidHJhbnNtaXNzaW9uVGV4dHVyZSIsInRoaWNrbmVzcyIsInRoaWNrbmVzc0ZhY3RvciIsInRoaWNrbmVzc1RleHR1cmUiLCJhdHRlbnVhdGlvbkRpc3RhbmNlIiwiSW5maW5pdHkiLCJjb2xvckFycmF5IiwiYXR0ZW51YXRpb25Db2xvciIsImlvciIsInNwZWN1bGFySW50ZW5zaXR5Iiwic3BlY3VsYXJGYWN0b3IiLCJzcGVjdWxhclRleHR1cmUiLCJzcGVjdWxhckNvbG9yRmFjdG9yIiwic3BlY3VsYXJDb2xvciIsInNwZWN1bGFyQ29sb3JUZXh0dXJlIiwiYW5pc290cm9weVN0cmVuZ3RoIiwiYW5pc290cm9weSIsImFuaXNvdHJvcHlSb3RhdGlvbiIsImFuaXNvdHJvcHlUZXh0dXJlIiwibG9hZFRleHR1cmUiLCJ0ZXh0dXJlSW5kZXgiLCJ0ZXh0dXJlRGVmIiwidGV4dHVyZXMiLCJvcHRpb25zIiwibG9hZFRleHR1cmVJbWFnZSIsInNvdXJjZSIsImlzU3VwcG9ydGVkIiwiaW1hZ2VzIiwidGV4dHVyZUxvYWRlciIsInVyaSIsImhhbmRsZXIiLCJnZXRIYW5kbGVyIiwiZGV0ZWN0U3VwcG9ydCIsImltYWdlIiwiSW1hZ2UiLCJzcmMiLCJvbmxvYWQiLCJvbmVycm9yIiwiaGVpZ2h0IiwibG9hZEJ1ZmZlclZpZXciLCJidWZmZXJWaWV3IiwiYnVmZmVyVmlld3MiLCJleHRlbnNpb25EZWYiLCJidWZmZXIiLCJkZWNvZGVyIiwic3VwcG9ydGVkIiwicmVzIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJjb3VudCIsInN0cmlkZSIsImJ5dGVTdHJpZGUiLCJkZWNvZGVHbHRmQnVmZmVyQXN5bmMiLCJtb2RlIiwiZmlsdGVyIiwicmVzMiIsInJlYWR5IiwicmVzdWx0IiwiZGVjb2RlR2x0ZkJ1ZmZlciIsImNyZWF0ZU5vZGVNZXNoIiwibWVzaCIsIm1lc2hEZWYiLCJtZXNoZXMiLCJwcmltaXRpdmUiLCJwcmltaXRpdmVzIiwiV0VCR0xfQ09OU1RBTlRTIiwiVFJJQU5HTEVTIiwiVFJJQU5HTEVfU1RSSVAiLCJUUklBTkdMRV9GQU4iLCJhdHRyaWJ1dGVzRGVmIiwiYXR0cmlidXRlcyIsImFjY2Vzc29yIiwicmVzdWx0cyIsIm5vZGVPYmplY3QiLCJwb3AiLCJpc0dyb3VwIiwiY2hpbGRyZW4iLCJpbnN0YW5jZWRNZXNoZXMiLCJtIiwicCIsInEiLCJzIiwiaW5zdGFuY2VkTWVzaCIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJUUkFOU0xBVElPTiIsImZyb21CdWZmZXJBdHRyaWJ1dGUiLCJST1RBVElPTiIsIlNDQUxFIiwic2V0TWF0cml4QXQiLCJjb21wb3NlIiwiYXR0cmlidXRlTmFtZSIsInNldEF0dHJpYnV0ZSIsInByb3RvdHlwZSIsImNvcHkiLCJjYWxsIiwiYXNzaWduRmluYWxNYXRlcmlhbCIsImNsZWFyIiwiQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIIiwiQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyIsIkJJTiIsImJvZHkiLCJoZWFkZXJWaWV3IiwiRGF0YVZpZXciLCJoZWFkZXIiLCJnZXRVaW50MzIiLCJjaHVua0NvbnRlbnRzTGVuZ3RoIiwiY2h1bmtWaWV3IiwiY2h1bmtJbmRleCIsImNodW5rTGVuZ3RoIiwiY2h1bmtUeXBlIiwiY29udGVudEFycmF5IiwicHJlbG9hZCIsImRlY29kZVByaW1pdGl2ZSIsImJ1ZmZlclZpZXdJbmRleCIsImdsdGZBdHRyaWJ1dGVNYXAiLCJ0aHJlZUF0dHJpYnV0ZU1hcCIsImF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAiLCJhdHRyaWJ1dGVUeXBlTWFwIiwidGhyZWVBdHRyaWJ1dGVOYW1lIiwiQVRUUklCVVRFUyIsInRvTG93ZXJDYXNlIiwiYWNjZXNzb3JEZWYiLCJhY2Nlc3NvcnMiLCJjb21wb25lbnRUeXBlIiwiV0VCR0xfQ09NUE9ORU5UX1RZUEVTIiwibm9ybWFsaXplZCIsImRlY29kZURyYWNvRmlsZSIsImF0dHJpYnV0ZSIsImV4dGVuZFRleHR1cmUiLCJ0ZXh0dXJlIiwidHJhbnNmb3JtIiwidGV4Q29vcmQiLCJjaGFubmVsIiwib2Zmc2V0Iiwicm90YXRpb24iLCJjbG9uZSIsInJlcGVhdCIsIm5lZWRzVXBkYXRlIiwiR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQiLCJwYXJhbWV0ZXJQb3NpdGlvbnMiLCJzYW1wbGVWYWx1ZXMiLCJzYW1wbGVTaXplIiwicmVzdWx0QnVmZmVyIiwiY29weVNhbXBsZVZhbHVlXyIsInZhbHVlcyIsInZhbHVlU2l6ZSIsImludGVycG9sYXRlXyIsImkxIiwidDAiLCJ0IiwidDEiLCJzdHJpZGUyIiwic3RyaWRlMyIsInRkIiwicHAiLCJwcHAiLCJvZmZzZXQxIiwib2Zmc2V0MCIsInMyIiwiczMiLCJzMCIsInMxIiwicDAiLCJtMCIsInAxIiwibTEiLCJfcSIsIkdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCIsIm5vcm1hbGl6ZSIsInRvQXJyYXkiLCJGTE9BVCIsIkZMT0FUX01BVDMiLCJGTE9BVF9NQVQ0IiwiRkxPQVRfVkVDMiIsIkZMT0FUX1ZFQzMiLCJGTE9BVF9WRUM0IiwiTElORUFSIiwiUkVQRUFUIiwiU0FNUExFUl8yRCIsIlBPSU5UUyIsIkxJTkVTIiwiTElORV9MT09QIiwiTElORV9TVFJJUCIsIlVOU0lHTkVEX0JZVEUiLCJVTlNJR05FRF9TSE9SVCIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiV0VCR0xfRklMVEVSUyIsIldFQkdMX1dSQVBQSU5HUyIsIldFQkdMX1RZUEVfU0laRVMiLCJTQ0FMQVIiLCJWRUMyIiwiVkVDMyIsIlZFQzQiLCJNQVQyIiwiTUFUMyIsIk1BVDQiLCJQT1NJVElPTiIsIk5PUk1BTCIsIlRBTkdFTlQiLCJURVhDT09SRF8wIiwiVEVYQ09PUkRfMSIsIlRFWENPT1JEXzIiLCJURVhDT09SRF8zIiwiQ09MT1JfMCIsIldFSUdIVFNfMCIsIkpPSU5UU18wIiwiUEFUSF9QUk9QRVJUSUVTIiwidHJhbnNsYXRpb24iLCJ3ZWlnaHRzIiwiSU5URVJQT0xBVElPTiIsIkNVQklDU1BMSU5FIiwiU1RFUCIsIkFMUEhBX01PREVTIiwiT1BBUVVFIiwiTUFTSyIsIkJMRU5EIiwiY3JlYXRlRGVmYXVsdE1hdGVyaWFsIiwiZW1pc3NpdmUiLCJtZXRhbG5lc3MiLCJyb3VnaG5lc3MiLCJ0cmFuc3BhcmVudCIsImRlcHRoVGVzdCIsInNpZGUiLCJhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEiLCJrbm93bkV4dGVuc2lvbnMiLCJvYmplY3REZWYiLCJ1c2VyRGF0YSIsImdsdGZFeHRlbnNpb25zIiwiZ2x0ZkRlZiIsImV4dHJhcyIsIk9iamVjdCIsImFzc2lnbiIsImFkZE1vcnBoVGFyZ2V0cyIsInRhcmdldHMiLCJoYXNNb3JwaFBvc2l0aW9uIiwiaGFzTW9ycGhOb3JtYWwiLCJoYXNNb3JwaENvbG9yIiwiaWwiLCJwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMiLCJwZW5kaW5nTm9ybWFsQWNjZXNzb3JzIiwicGVuZGluZ0NvbG9yQWNjZXNzb3JzIiwicGVuZGluZ0FjY2Vzc29yIiwibm9ybWFsIiwibW9ycGhQb3NpdGlvbnMiLCJtb3JwaE5vcm1hbHMiLCJtb3JwaENvbG9ycyIsIm1vcnBoQXR0cmlidXRlcyIsIm1vcnBoVGFyZ2V0c1JlbGF0aXZlIiwidXBkYXRlTW9ycGhUYXJnZXRzIiwibW9ycGhUYXJnZXRJbmZsdWVuY2VzIiwidGFyZ2V0TmFtZXMiLCJtb3JwaFRhcmdldERpY3Rpb25hcnkiLCJjcmVhdGVQcmltaXRpdmVLZXkiLCJwcmltaXRpdmVEZWYiLCJnZW9tZXRyeUtleSIsImRyYWNvRXh0ZW5zaW9uIiwiaW5kaWNlcyIsImNyZWF0ZUF0dHJpYnV0ZXNLZXkiLCJhdHRyaWJ1dGVzS2V5Iiwia2V5cyIsInNvcnQiLCJnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUiLCJnZXRJbWFnZVVSSU1pbWVUeXBlIiwic2VhcmNoIiwiX2lkZW50aXR5TWF0cml4IiwiYXNzb2NpYXRpb25zIiwiTWFwIiwicHJpbWl0aXZlQ2FjaGUiLCJub2RlQ2FjaGUiLCJtZXNoQ2FjaGUiLCJjYW1lcmFDYWNoZSIsImxpZ2h0Q2FjaGUiLCJzb3VyY2VDYWNoZSIsInRleHR1cmVDYWNoZSIsIm5vZGVOYW1lc1VzZWQiLCJpc1NhZmFyaSIsImlzRmlyZWZveCIsImZpcmVmb3hWZXJzaW9uIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidGVzdCIsIm1hdGNoIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJzZXRDcm9zc09yaWdpbiIsIl9pbnZva2VBbGwiLCJleHQiLCJiZWZvcmVSb290IiwiZ2V0RGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwic2NlbmUiLCJzY2VuZXMiLCJhbmltYXRpb25zIiwiY2FtZXJhcyIsImFmdGVyUm9vdCIsImNhdGNoIiwic2tpbkRlZnMiLCJza2lucyIsIm1lc2hEZWZzIiwic2tpbkluZGV4Iiwic2tpbkxlbmd0aCIsImpvaW50cyIsImlzQm9uZSIsInNraW4iLCJpc1NraW5uZWRNZXNoIiwiY2FtZXJhIiwicmVmIiwidXBkYXRlTWFwcGluZ3MiLCJvcmlnaW5hbCIsIm1hcHBpbmdzIiwiY2hpbGQiLCJlbnRyaWVzIiwiX2ludm9rZU9uZSIsImZ1bmMiLCJ1bnNoaWZ0IiwibG9hZFNjZW5lIiwibG9hZE5vZGUiLCJsb2FkTWVzaCIsImxvYWRBY2Nlc3NvciIsImxvYWRCdWZmZXIiLCJsb2FkTWF0ZXJpYWwiLCJsb2FkU2tpbiIsImxvYWRBbmltYXRpb24iLCJsb2FkQ2FtZXJhIiwiZGVmcyIsIm1hcCIsImRlZiIsImJ1ZmZlckluZGV4IiwiYnVmZmVyRGVmIiwiYnVmZmVycyIsInJlc29sdmVVUkwiLCJidWZmZXJWaWV3RGVmIiwiYWNjZXNzb3JJbmRleCIsInNwYXJzZSIsIml0ZW1TaXplIiwiVHlwZWRBcnJheSIsInBlbmRpbmdCdWZmZXJWaWV3cyIsImVsZW1lbnRCeXRlcyIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiaXRlbUJ5dGVzIiwiYnVmZmVyQXR0cmlidXRlIiwiaWJTbGljZSIsImZsb29yIiwiaWJDYWNoZUtleSIsImliIiwiaXRlbVNpemVJbmRpY2VzIiwiVHlwZWRBcnJheUluZGljZXMiLCJieXRlT2Zmc2V0SW5kaWNlcyIsImJ5dGVPZmZzZXRWYWx1ZXMiLCJzcGFyc2VJbmRpY2VzIiwic3BhcnNlVmFsdWVzIiwic2V0WCIsInNldFkiLCJzZXRaIiwic2V0VyIsInNvdXJjZUluZGV4Iiwic291cmNlRGVmIiwic2FtcGxlciIsInByb21pc2UiLCJsb2FkSW1hZ2VTb3VyY2UiLCJmbGlwWSIsInN0YXJ0c1dpdGgiLCJzYW1wbGVycyIsIm1hZ0ZpbHRlciIsIm1pbkZpbHRlciIsIndyYXBTIiwid3JhcFQiLCJVUkwiLCJzZWxmIiwid2Via2l0VVJMIiwic291cmNlVVJJIiwiaXNPYmplY3RVUkwiLCJibG9iIiwiQmxvYiIsIm1pbWVUeXBlIiwiY3JlYXRlT2JqZWN0VVJMIiwic291cmNlVVJJMiIsImlzSW1hZ2VCaXRtYXBMb2FkZXIiLCJpbWFnZUJpdG1hcCIsInJldm9rZU9iamVjdFVSTCIsIm1hcE5hbWUiLCJtYXBEZWYiLCJlbmNvZGluZyIsImdsdGZSZWZlcmVuY2UiLCJjb2xvclNwYWNlIiwidXNlRGVyaXZhdGl2ZVRhbmdlbnRzIiwidGFuZ2VudCIsInVzZVZlcnRleENvbG9ycyIsInVzZUZsYXRTaGFkaW5nIiwiaXNQb2ludHMiLCJ1dWlkIiwicG9pbnRzTWF0ZXJpYWwiLCJzaXplQXR0ZW51YXRpb24iLCJpc0xpbmUiLCJsaW5lTWF0ZXJpYWwiLCJjYWNoZWRNYXRlcmlhbCIsInZlcnRleENvbG9ycyIsImZsYXRTaGFkaW5nIiwibm9ybWFsU2NhbGUiLCJ5IiwibWF0ZXJpYWxUeXBlIiwibWF0ZXJpYWxFeHRlbnNpb25zIiwia211RXh0ZW5zaW9uIiwibWV0YWxsaWNGYWN0b3IiLCJyb3VnaG5lc3NGYWN0b3IiLCJtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUiLCJkb3VibGVTaWRlZCIsImFscGhhTW9kZSIsImRlcHRoV3JpdGUiLCJhbHBoYVRlc3QiLCJhbHBoYUN1dG9mZiIsIm5vcm1hbFRleHR1cmUiLCJvY2NsdXNpb25UZXh0dXJlIiwic3RyZW5ndGgiLCJhb01hcEludGVuc2l0eSIsImVtaXNzaXZlRmFjdG9yIiwiZW1pc3NpdmVUZXh0dXJlIiwib3JpZ2luYWxOYW1lIiwic2FuaXRpemVkTmFtZSIsInNhbml0aXplTm9kZU5hbWUiLCJsb2FkR2VvbWV0cmllcyIsImNyZWF0ZURyYWNvUHJpbWl0aXZlIiwiYWRkUHJpbWl0aXZlQXR0cmlidXRlcyIsImNhY2hlZCIsImdlb21ldHJ5UHJvbWlzZSIsIm1lc2hJbmRleCIsImdlb21ldHJpZXMiLCJub3JtYWxpemVTa2luV2VpZ2h0cyIsImdyb3VwIiwiY2FtZXJhSW5kZXgiLCJjYW1lcmFEZWYiLCJwYXJhbXMiLCJyYWRUb0RlZyIsInlmb3YiLCJhc3BlY3RSYXRpbyIsInpuZWFyIiwiemZhciIsInhtYWciLCJ5bWFnIiwic2tpbkRlZiIsIl9sb2FkTm9kZVNoYWxsb3ciLCJpbnZlcnNlQmluZE1hdHJpY2VzIiwiam9pbnROb2RlcyIsImJvbmVzIiwiYm9uZUludmVyc2VzIiwiam9pbnROb2RlIiwibWF0IiwiYW5pbWF0aW9uSW5kZXgiLCJhbmltYXRpb25EZWYiLCJhbmltYXRpb25OYW1lIiwicGVuZGluZ05vZGVzIiwicGVuZGluZ0lucHV0QWNjZXNzb3JzIiwicGVuZGluZ091dHB1dEFjY2Vzc29ycyIsInBlbmRpbmdTYW1wbGVycyIsInBlbmRpbmdUYXJnZXRzIiwiY2hhbm5lbHMiLCJub2RlIiwiaW5wdXQiLCJwYXJhbWV0ZXJzIiwib3V0cHV0IiwiaW5wdXRBY2Nlc3NvcnMiLCJvdXRwdXRBY2Nlc3NvcnMiLCJ0cmFja3MiLCJpbnB1dEFjY2Vzc29yIiwib3V0cHV0QWNjZXNzb3IiLCJ1cGRhdGVNYXRyaXgiLCJUeXBlZEtleWZyYW1lVHJhY2siLCJ0YXJnZXROYW1lIiwiaW50ZXJwb2xhdGlvbiIsInRyYXZlcnNlIiwib3V0cHV0QXJyYXkiLCJzY2FsZWQiLCJqIiwiamwiLCJ0cmFjayIsImNyZWF0ZUludGVycG9sYW50IiwiSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lIiwiaW50ZXJwb2xhbnRUeXBlIiwidGltZXMiLCJnZXRWYWx1ZVNpemUiLCJpc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSIsIm8iLCJpc01lc2giLCJub2RlUGVuZGluZyIsImNoaWxkUGVuZGluZyIsImNoaWxkcmVuRGVmIiwic2tlbGV0b25QZW5kaW5nIiwic2tlbGV0b24iLCJiaW5kIiwibm9kZU5hbWUiLCJtZXNoUHJvbWlzZSIsImZvckVhY2giLCJtYXRyaXgiLCJhcHBseU1hdHJpeDQiLCJxdWF0ZXJuaW9uIiwiaGFzIiwic2NlbmVJbmRleCIsInNjZW5lRGVmIiwibm9kZUlkcyIsInJlZHVjZUFzc29jaWF0aW9ucyIsInJlZHVjZWRBc3NvY2lhdGlvbnMiLCJ2YWx1ZSIsIm5vZGUyIiwiY29tcHV0ZUJvdW5kcyIsImJveCIsIm1pbiIsIm1heCIsImJveFNjYWxlIiwibXVsdGlwbHlTY2FsYXIiLCJtYXhEaXNwbGFjZW1lbnQiLCJ2ZWN0b3IiLCJhYnMiLCJleHBhbmRCeVZlY3RvciIsImJvdW5kaW5nQm94Iiwic3BoZXJlIiwiZ2V0Q2VudGVyIiwiY2VudGVyIiwicmFkaXVzIiwiZGlzdGFuY2VUbyIsImJvdW5kaW5nU3BoZXJlIiwiYXNzaWduQXR0cmlidXRlQWNjZXNzb3IiLCJnbHRmQXR0cmlidXRlTmFtZSIsImFjY2Vzc29yMiIsInNldEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key)=>obj[key];\n //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWEsQ0FBQ0MsS0FBS0MsTUFBUUQsR0FBRyxDQUFDQyxJQUFJO0FBR3ZDLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanM/MmY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBnZXRXaXRoS2V5ID0gKG9iaiwga2V5KSA9PiBvYmpba2V5XTtcbmV4cG9ydCB7XG4gIGdldFdpdGhLZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdldFdpdGhLZXkiLCJvYmoiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups)=>{\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    geometries.forEach((geom, i)=>{\n        let attributesCount = 0;\n        if (isIndexed !== (geom.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        for(let name in geom.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === void 0) {\n                attributes[name] = [];\n            }\n            attributes[name].push(geom.attributes[name]);\n            attributesCount++;\n        }\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        if (morphTargetsRelative !== geom.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(let name in geom.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n            morphAttributes[name].push(geom.morphAttributes[name]);\n        }\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geom.userData);\n        if (useGroups) {\n            let count;\n            if (geom.index) {\n                count = geom.index.count;\n            } else if (geom.attributes.position !== void 0) {\n                count = geom.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    });\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        geometries.forEach((geom)=>{\n            const index = geom.index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geom.attributes.position.count;\n        });\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    for(let name in attributes){\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    for(let name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let itemSize = void 0;\n    let normalized = void 0;\n    let arrayLength = 0;\n    attributes.forEach((attr)=>{\n        if (TypedArray === void 0) {\n            TypedArray = attr.array.constructor;\n        }\n        if (TypedArray !== attr.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === void 0) itemSize = attr.itemSize;\n        if (itemSize !== attr.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === void 0) normalized = attr.normalized;\n        if (normalized !== attr.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attr.array.length;\n    });\n    if (TypedArray && itemSize) {\n        const array = new TypedArray(arrayLength);\n        let offset = 0;\n        attributes.forEach((attr)=>{\n            array.set(attr.array, offset);\n            offset += attr.array.length;\n        });\n        return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n};\nconst interleaveAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let arrayLength = 0;\n    let stride = 0;\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n                const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n                set(c, get(c));\n            }\n        }\n    }\n    return res;\n};\nfunction estimateBytesUsed(geometry) {\n    let mem = 0;\n    for(let name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    let nextIndex = 0;\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        attrArrays[name] = [];\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);\n        }\n    }\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n            }\n        }\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    const result = geometry.clone();\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n        result.setAttribute(name, attribute);\n        if (name in morphAttrsArrays) {\n            for(let j = 0; j < morphAttrsArrays[name].length; j++){\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n            }\n        }\n    }\n    result.setIndex(newIndices);\n    return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== void 0) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (index) {\n            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n                for(let i = 1; i <= numberOfTriangles; i++){\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for(let i = 0; i < numberOfTriangles; i++){\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\nfunction computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n        console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n        return null;\n    }\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a2);\n        _vB.fromBufferAttribute(attribute, b2);\n        _vC.fromBufferAttribute(attribute, c2);\n        const morphInfluences = object2.morphTargetInfluences;\n        if (// @ts-ignore\n        material2.morphTargets && morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){\n                const influence = morphInfluences[i2];\n                const morph = morphAttribute[i2];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a2);\n                _tempB.fromBufferAttribute(morph, b2);\n                _tempC.fromBufferAttribute(morph, c2);\n                if (morphTargetsRelative2) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object2.isSkinnedMesh) {\n            object2.boneTransform(a2, _vA);\n            object2.boneTransform(b2, _vB);\n            object2.boneTransform(c2, _vC);\n        }\n        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else if (positionAttribute !== void 0) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute,\n        normalAttribute,\n        morphedPositionAttribute,\n        morphedNormalAttribute\n    };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 100;\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n //# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRCxNQUFNVSx3QkFBd0IsQ0FBQ0MsWUFBWUM7SUFDekMsTUFBTUMsWUFBWUYsVUFBVSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxLQUFLO0lBQzFDLE1BQU1DLGlCQUFpQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNQLFVBQVUsQ0FBQyxFQUFFLENBQUNRLFVBQVU7SUFDbkUsTUFBTUMsc0JBQXNCLElBQUlKLElBQUlDLE9BQU9DLElBQUksQ0FBQ1AsVUFBVSxDQUFDLEVBQUUsQ0FBQ1UsZUFBZTtJQUM3RSxNQUFNRixhQUFhLENBQUM7SUFDcEIsTUFBTUUsa0JBQWtCLENBQUM7SUFDekIsTUFBTUMsdUJBQXVCWCxVQUFVLENBQUMsRUFBRSxDQUFDVyxvQkFBb0I7SUFDL0QsTUFBTUMsaUJBQWlCLElBQUl2QixpREFBY0E7SUFDekMsSUFBSXdCLFNBQVM7SUFDYmIsV0FBV2MsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQ3hCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJZixjQUFlYSxDQUFBQSxLQUFLWixLQUFLLEtBQUssSUFBRyxHQUFJO1lBQ3ZDZSxRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO1lBRTdGLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUksUUFBUUwsS0FBS1AsVUFBVSxDQUFFO1lBQ2hDLElBQUksQ0FBQ0osZUFBZWlCLEdBQUcsQ0FBQ0QsT0FBTztnQkFDN0JGLFFBQVFDLEtBQUssQ0FDWCx1RkFBdUZILElBQUksa0VBQWtFSSxPQUFPO2dCQUV0SyxPQUFPO1lBQ1Q7WUFDQSxJQUFJWixVQUFVLENBQUNZLEtBQUssS0FBSyxLQUFLLEdBQUc7Z0JBQy9CWixVQUFVLENBQUNZLEtBQUssR0FBRyxFQUFFO1lBQ3ZCO1lBQ0FaLFVBQVUsQ0FBQ1ksS0FBSyxDQUFDRSxJQUFJLENBQUNQLEtBQUtQLFVBQVUsQ0FBQ1ksS0FBSztZQUMzQ0g7UUFDRjtRQUNBLElBQUlBLG9CQUFvQmIsZUFBZW1CLElBQUksRUFBRTtZQUMzQ0wsUUFBUUMsS0FBSyxDQUNYLHVGQUF1RkgsSUFBSTtZQUU3RixPQUFPO1FBQ1Q7UUFDQSxJQUFJTCx5QkFBeUJJLEtBQUtKLG9CQUFvQixFQUFFO1lBQ3RETyxRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO1lBRTdGLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUksUUFBUUwsS0FBS0wsZUFBZSxDQUFFO1lBQ3JDLElBQUksQ0FBQ0Qsb0JBQW9CWSxHQUFHLENBQUNELE9BQU87Z0JBQ2xDRixRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO2dCQUU3RixPQUFPO1lBQ1Q7WUFDQSxJQUFJTixlQUFlLENBQUNVLEtBQUssS0FBSyxLQUFLLEdBQ2pDVixlQUFlLENBQUNVLEtBQUssR0FBRyxFQUFFO1lBQzVCVixlQUFlLENBQUNVLEtBQUssQ0FBQ0UsSUFBSSxDQUFDUCxLQUFLTCxlQUFlLENBQUNVLEtBQUs7UUFDdkQ7UUFDQVIsZUFBZVksUUFBUSxDQUFDQyxjQUFjLEdBQUdiLGVBQWVZLFFBQVEsQ0FBQ0MsY0FBYyxJQUFJLEVBQUU7UUFDckZiLGVBQWVZLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDSCxJQUFJLENBQUNQLEtBQUtTLFFBQVE7UUFDekQsSUFBSXZCLFdBQVc7WUFDYixJQUFJeUI7WUFDSixJQUFJWCxLQUFLWixLQUFLLEVBQUU7Z0JBQ2R1QixRQUFRWCxLQUFLWixLQUFLLENBQUN1QixLQUFLO1lBQzFCLE9BQU8sSUFBSVgsS0FBS1AsVUFBVSxDQUFDbUIsUUFBUSxLQUFLLEtBQUssR0FBRztnQkFDOUNELFFBQVFYLEtBQUtQLFVBQVUsQ0FBQ21CLFFBQVEsQ0FBQ0QsS0FBSztZQUN4QyxPQUFPO2dCQUNMUixRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO2dCQUU3RixPQUFPO1lBQ1Q7WUFDQUosZUFBZWdCLFFBQVEsQ0FBQ2YsUUFBUWEsT0FBT1Y7WUFDdkNILFVBQVVhO1FBQ1o7SUFDRjtJQUNBLElBQUl4QixXQUFXO1FBQ2IsSUFBSTJCLGNBQWM7UUFDbEIsTUFBTUMsY0FBYyxFQUFFO1FBQ3RCOUIsV0FBV2MsT0FBTyxDQUFDLENBQUNDO1lBQ2xCLE1BQU1aLFFBQVFZLEtBQUtaLEtBQUs7WUFDeEIsSUFBSyxJQUFJNEIsSUFBSSxHQUFHQSxJQUFJNUIsTUFBTXVCLEtBQUssRUFBRSxFQUFFSyxFQUFHO2dCQUNwQ0QsWUFBWVIsSUFBSSxDQUFDbkIsTUFBTTZCLElBQUksQ0FBQ0QsS0FBS0Y7WUFDbkM7WUFDQUEsZUFBZWQsS0FBS1AsVUFBVSxDQUFDbUIsUUFBUSxDQUFDRCxLQUFLO1FBQy9DO1FBQ0FkLGVBQWVxQixRQUFRLENBQUNIO0lBQzFCO0lBQ0EsSUFBSyxJQUFJVixRQUFRWixXQUFZO1FBQzNCLE1BQU0wQixrQkFBa0JDLHNCQUFzQjNCLFVBQVUsQ0FBQ1ksS0FBSztRQUM5RCxJQUFJLENBQUNjLGlCQUFpQjtZQUNwQmhCLFFBQVFDLEtBQUssQ0FDWCwwRkFBMEZDLE9BQU87WUFFbkcsT0FBTztRQUNUO1FBQ0FSLGVBQWV3QixZQUFZLENBQUNoQixNQUFNYztJQUNwQztJQUNBLElBQUssSUFBSWQsUUFBUVYsZ0JBQWlCO1FBQ2hDLE1BQU0yQixrQkFBa0IzQixlQUFlLENBQUNVLEtBQUssQ0FBQyxFQUFFLENBQUNrQixNQUFNO1FBQ3ZELElBQUlELG9CQUFvQixHQUN0QjtRQUNGekIsZUFBZUYsZUFBZSxHQUFHRSxlQUFlRixlQUFlLElBQUksQ0FBQztRQUNwRUUsZUFBZUYsZUFBZSxDQUFDVSxLQUFLLEdBQUcsRUFBRTtRQUN6QyxJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSXFCLGlCQUFpQixFQUFFckIsRUFBRztZQUN4QyxNQUFNdUIseUJBQXlCLEVBQUU7WUFDakMsSUFBSyxJQUFJUixJQUFJLEdBQUdBLElBQUlyQixlQUFlLENBQUNVLEtBQUssQ0FBQ2tCLE1BQU0sRUFBRSxFQUFFUCxFQUFHO2dCQUNyRFEsdUJBQXVCakIsSUFBSSxDQUFDWixlQUFlLENBQUNVLEtBQUssQ0FBQ1csRUFBRSxDQUFDZixFQUFFO1lBQ3pEO1lBQ0EsTUFBTXdCLHVCQUF1Qkwsc0JBQXNCSTtZQUNuRCxJQUFJLENBQUNDLHNCQUFzQjtnQkFDekJ0QixRQUFRQyxLQUFLLENBQ1gsMEZBQTBGQyxPQUFPO2dCQUVuRyxPQUFPO1lBQ1Q7WUFDQVIsZUFBZUYsZUFBZSxDQUFDVSxLQUFLLENBQUNFLElBQUksQ0FBQ2tCO1FBQzVDO0lBQ0Y7SUFDQSxPQUFPNUI7QUFDVDtBQUNBLE1BQU11Qix3QkFBd0IsQ0FBQzNCO0lBQzdCLElBQUlpQyxhQUFhLEtBQUs7SUFDdEIsSUFBSUMsV0FBVyxLQUFLO0lBQ3BCLElBQUlDLGFBQWEsS0FBSztJQUN0QixJQUFJQyxjQUFjO0lBQ2xCcEMsV0FBV00sT0FBTyxDQUFDLENBQUMrQjtRQUNsQixJQUFJSixlQUFlLEtBQUssR0FBRztZQUN6QkEsYUFBYUksS0FBS0MsS0FBSyxDQUFDQyxXQUFXO1FBQ3JDO1FBQ0EsSUFBSU4sZUFBZUksS0FBS0MsS0FBSyxDQUFDQyxXQUFXLEVBQUU7WUFDekM3QixRQUFRQyxLQUFLLENBQ1g7WUFFRixPQUFPO1FBQ1Q7UUFDQSxJQUFJdUIsYUFBYSxLQUFLLEdBQ3BCQSxXQUFXRyxLQUFLSCxRQUFRO1FBQzFCLElBQUlBLGFBQWFHLEtBQUtILFFBQVEsRUFBRTtZQUM5QnhCLFFBQVFDLEtBQUssQ0FDWDtZQUVGLE9BQU87UUFDVDtRQUNBLElBQUl3QixlQUFlLEtBQUssR0FDdEJBLGFBQWFFLEtBQUtGLFVBQVU7UUFDOUIsSUFBSUEsZUFBZUUsS0FBS0YsVUFBVSxFQUFFO1lBQ2xDekIsUUFBUUMsS0FBSyxDQUNYO1lBRUYsT0FBTztRQUNUO1FBQ0F5QixlQUFlQyxLQUFLQyxLQUFLLENBQUNSLE1BQU07SUFDbEM7SUFDQSxJQUFJRyxjQUFjQyxVQUFVO1FBQzFCLE1BQU1JLFFBQVEsSUFBSUwsV0FBV0c7UUFDN0IsSUFBSS9CLFNBQVM7UUFDYkwsV0FBV00sT0FBTyxDQUFDLENBQUMrQjtZQUNsQkMsTUFBTUUsR0FBRyxDQUFDSCxLQUFLQyxLQUFLLEVBQUVqQztZQUN0QkEsVUFBVWdDLEtBQUtDLEtBQUssQ0FBQ1IsTUFBTTtRQUM3QjtRQUNBLE9BQU8sSUFBSWhELGtEQUFlQSxDQUFDd0QsT0FBT0osVUFBVUM7SUFDOUM7QUFDRjtBQUNBLE1BQU1NLHVCQUF1QixDQUFDekM7SUFDNUIsSUFBSWlDLGFBQWEsS0FBSztJQUN0QixJQUFJRyxjQUFjO0lBQ2xCLElBQUlNLFNBQVM7SUFDYixJQUFLLElBQUlsQyxJQUFJLEdBQUdtQyxJQUFJM0MsV0FBVzhCLE1BQU0sRUFBRXRCLElBQUltQyxHQUFHLEVBQUVuQyxFQUFHO1FBQ2pELE1BQU1vQyxZQUFZNUMsVUFBVSxDQUFDUSxFQUFFO1FBQy9CLElBQUl5QixlQUFlLEtBQUssR0FDdEJBLGFBQWFXLFVBQVVOLEtBQUssQ0FBQ0MsV0FBVztRQUMxQyxJQUFJTixlQUFlVyxVQUFVTixLQUFLLENBQUNDLFdBQVcsRUFBRTtZQUM5QzdCLFFBQVFDLEtBQUssQ0FBQztZQUNkLE9BQU87UUFDVDtRQUNBeUIsZUFBZVEsVUFBVU4sS0FBSyxDQUFDUixNQUFNO1FBQ3JDWSxVQUFVRSxVQUFVVixRQUFRO0lBQzlCO0lBQ0EsTUFBTVcsb0JBQW9CLElBQUk5RCxvREFBaUJBLENBQUMsSUFBSWtELFdBQVdHLGNBQWNNO0lBQzdFLElBQUlyQyxTQUFTO0lBQ2IsTUFBTXlDLE1BQU0sRUFBRTtJQUNkLE1BQU1DLFVBQVU7UUFBQztRQUFRO1FBQVE7UUFBUTtLQUFPO0lBQ2hELE1BQU1DLFVBQVU7UUFBQztRQUFRO1FBQVE7UUFBUTtLQUFPO0lBQ2hELElBQUssSUFBSXpCLElBQUksR0FBR29CLElBQUkzQyxXQUFXOEIsTUFBTSxFQUFFUCxJQUFJb0IsR0FBR3BCLElBQUs7UUFDakQsTUFBTXFCLFlBQVk1QyxVQUFVLENBQUN1QixFQUFFO1FBQy9CLE1BQU1XLFdBQVdVLFVBQVVWLFFBQVE7UUFDbkMsTUFBTWhCLFFBQVEwQixVQUFVMUIsS0FBSztRQUM3QixNQUFNK0IsTUFBTSxJQUFJakUsNkRBQTBCQSxDQUFDNkQsbUJBQW1CWCxVQUFVN0IsUUFBUXVDLFVBQVVULFVBQVU7UUFDcEdXLElBQUloQyxJQUFJLENBQUNtQztRQUNUNUMsVUFBVTZCO1FBQ1YsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJaEMsT0FBT2dDLElBQUs7WUFDOUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlqQixVQUFVaUIsSUFBSztnQkFDakMsTUFBTVgsTUFBTWxELDZEQUFVQSxDQUFDMkQsS0FBS0QsT0FBTyxDQUFDRyxFQUFFO2dCQUN0QyxNQUFNQyxNQUFNOUQsNkRBQVVBLENBQUNzRCxXQUFXRyxPQUFPLENBQUNJLEVBQUU7Z0JBQzVDWCxJQUFJVSxHQUFHRSxJQUFJRjtZQUNiO1FBQ0Y7SUFDRjtJQUNBLE9BQU9KO0FBQ1Q7QUFDQSxTQUFTTyxrQkFBa0JDLFFBQVE7SUFDakMsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSTNDLFFBQVEwQyxTQUFTdEQsVUFBVSxDQUFFO1FBQ3BDLE1BQU1xQyxPQUFPaUIsU0FBU0UsWUFBWSxDQUFDNUM7UUFDbkMyQyxPQUFPbEIsS0FBS25CLEtBQUssR0FBR21CLEtBQUtILFFBQVEsR0FBR0csS0FBS0MsS0FBSyxDQUFDbUIsaUJBQWlCO0lBQ2xFO0lBQ0EsTUFBTUMsVUFBVUosU0FBU0ssUUFBUTtJQUNqQ0osT0FBT0csVUFBVUEsUUFBUXhDLEtBQUssR0FBR3dDLFFBQVF4QixRQUFRLEdBQUd3QixRQUFRcEIsS0FBSyxDQUFDbUIsaUJBQWlCLEdBQUc7SUFDdEYsT0FBT0Y7QUFDVDtBQUNBLFNBQVNLLGNBQWNOLFFBQVEsRUFBRU8sWUFBWSxJQUFJO0lBQy9DQSxZQUFZQyxLQUFLQyxHQUFHLENBQUNGLFdBQVdHLE9BQU9DLE9BQU87SUFDOUMsTUFBTUMsY0FBYyxDQUFDO0lBQ3JCLE1BQU1SLFVBQVVKLFNBQVNLLFFBQVE7SUFDakMsTUFBTVEsWUFBWWIsU0FBU0UsWUFBWSxDQUFDO0lBQ3hDLE1BQU1ZLGNBQWNWLFVBQVVBLFFBQVF4QyxLQUFLLEdBQUdpRCxVQUFVakQsS0FBSztJQUM3RCxJQUFJbUQsWUFBWTtJQUNoQixNQUFNQyxpQkFBaUJ4RSxPQUFPQyxJQUFJLENBQUN1RCxTQUFTdEQsVUFBVTtJQUN0RCxNQUFNdUUsYUFBYSxDQUFDO0lBQ3BCLE1BQU1DLG1CQUFtQixDQUFDO0lBQzFCLE1BQU1DLGFBQWEsRUFBRTtJQUNyQixNQUFNMUIsVUFBVTtRQUFDO1FBQVE7UUFBUTtRQUFRO0tBQU87SUFDaEQsSUFBSyxJQUFJdkMsSUFBSSxHQUFHbUMsSUFBSTJCLGVBQWV4QyxNQUFNLEVBQUV0QixJQUFJbUMsR0FBR25DLElBQUs7UUFDckQsTUFBTUksT0FBTzBELGNBQWMsQ0FBQzlELEVBQUU7UUFDOUIrRCxVQUFVLENBQUMzRCxLQUFLLEdBQUcsRUFBRTtRQUNyQixNQUFNOEQsWUFBWXBCLFNBQVNwRCxlQUFlLENBQUNVLEtBQUs7UUFDaEQsSUFBSThELFdBQVc7WUFDYkYsZ0JBQWdCLENBQUM1RCxLQUFLLEdBQUcsSUFBSStELE1BQU1ELFVBQVU1QyxNQUFNLEVBQUU4QyxJQUFJLENBQUMsR0FBR0MsR0FBRyxDQUFDLElBQU0sRUFBRTtRQUMzRTtJQUNGO0lBQ0EsTUFBTUMsZUFBZWhCLEtBQUtpQixLQUFLLENBQUMsSUFBSWxCO0lBQ3BDLE1BQU1tQixrQkFBa0JsQixLQUFLbUIsR0FBRyxDQUFDLElBQUlIO0lBQ3JDLElBQUssSUFBSXRFLElBQUksR0FBR0EsSUFBSTRELGFBQWE1RCxJQUFLO1FBQ3BDLE1BQU1iLFFBQVErRCxVQUFVQSxRQUFRbEMsSUFBSSxDQUFDaEIsS0FBS0E7UUFDMUMsSUFBSTBFLE9BQU87UUFDWCxJQUFLLElBQUkzRCxJQUFJLEdBQUdvQixJQUFJMkIsZUFBZXhDLE1BQU0sRUFBRVAsSUFBSW9CLEdBQUdwQixJQUFLO1lBQ3JELE1BQU1YLE9BQU8wRCxjQUFjLENBQUMvQyxFQUFFO1lBQzlCLE1BQU1xQixZQUFZVSxTQUFTRSxZQUFZLENBQUM1QztZQUN4QyxNQUFNc0IsV0FBV1UsVUFBVVYsUUFBUTtZQUNuQyxJQUFLLElBQUlpQixJQUFJLEdBQUdBLElBQUlqQixVQUFVaUIsSUFBSztnQkFDakMrQixRQUFRLENBQUMsRUFBRSxDQUFDLENBQUV0QyxDQUFBQSxTQUFTLENBQUNHLE9BQU8sQ0FBQ0ksRUFBRSxDQUFDLENBQUN4RCxTQUFTcUYsZUFBYyxFQUFHLENBQUMsQ0FBQztZQUNsRTtRQUNGO1FBQ0EsSUFBSUUsUUFBUWhCLGFBQWE7WUFDdkJPLFdBQVczRCxJQUFJLENBQUNvRCxXQUFXLENBQUNnQixLQUFLO1FBQ25DLE9BQU87WUFDTCxJQUFLLElBQUkzRCxJQUFJLEdBQUdvQixJQUFJMkIsZUFBZXhDLE1BQU0sRUFBRVAsSUFBSW9CLEdBQUdwQixJQUFLO2dCQUNyRCxNQUFNWCxPQUFPMEQsY0FBYyxDQUFDL0MsRUFBRTtnQkFDOUIsTUFBTXFCLFlBQVlVLFNBQVNFLFlBQVksQ0FBQzVDO2dCQUN4QyxNQUFNOEQsWUFBWXBCLFNBQVNwRCxlQUFlLENBQUNVLEtBQUs7Z0JBQ2hELE1BQU1zQixXQUFXVSxVQUFVVixRQUFRO2dCQUNuQyxNQUFNaUQsV0FBV1osVUFBVSxDQUFDM0QsS0FBSztnQkFDakMsTUFBTXdFLGlCQUFpQlosZ0JBQWdCLENBQUM1RCxLQUFLO2dCQUM3QyxJQUFLLElBQUl1QyxJQUFJLEdBQUdBLElBQUlqQixVQUFVaUIsSUFBSztvQkFDakMsTUFBTWtDLGFBQWF0QyxPQUFPLENBQUNJLEVBQUU7b0JBQzdCZ0MsU0FBU3JFLElBQUksQ0FBQzhCLFNBQVMsQ0FBQ3lDLFdBQVcsQ0FBQzFGO29CQUNwQyxJQUFJK0UsV0FBVzt3QkFDYixJQUFLLElBQUlZLElBQUksR0FBR0MsS0FBS2IsVUFBVTVDLE1BQU0sRUFBRXdELElBQUlDLElBQUlELElBQUs7NEJBQ2xERixjQUFjLENBQUNFLEVBQUUsQ0FBQ3hFLElBQUksQ0FBQzRELFNBQVMsQ0FBQ1ksRUFBRSxDQUFDRCxXQUFXLENBQUMxRjt3QkFDbEQ7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBdUUsV0FBVyxDQUFDZ0IsS0FBSyxHQUFHYjtZQUNwQkksV0FBVzNELElBQUksQ0FBQ3VEO1lBQ2hCQTtRQUNGO0lBQ0Y7SUFDQSxNQUFNbUIsU0FBU2xDLFNBQVNtQyxLQUFLO0lBQzdCLElBQUssSUFBSWpGLElBQUksR0FBR21DLElBQUkyQixlQUFleEMsTUFBTSxFQUFFdEIsSUFBSW1DLEdBQUduQyxJQUFLO1FBQ3JELE1BQU1JLE9BQU8wRCxjQUFjLENBQUM5RCxFQUFFO1FBQzlCLE1BQU1rRixlQUFlcEMsU0FBU0UsWUFBWSxDQUFDNUM7UUFDM0MsTUFBTStFLFNBQVMsSUFBSUQsYUFBYXBELEtBQUssQ0FBQ0MsV0FBVyxDQUFDZ0MsVUFBVSxDQUFDM0QsS0FBSztRQUNsRSxNQUFNZ0MsWUFBWSxJQUFJOUQsa0RBQWVBLENBQUM2RyxRQUFRRCxhQUFheEQsUUFBUSxFQUFFd0QsYUFBYXZELFVBQVU7UUFDNUZxRCxPQUFPNUQsWUFBWSxDQUFDaEIsTUFBTWdDO1FBQzFCLElBQUloQyxRQUFRNEQsa0JBQWtCO1lBQzVCLElBQUssSUFBSWpELElBQUksR0FBR0EsSUFBSWlELGdCQUFnQixDQUFDNUQsS0FBSyxDQUFDa0IsTUFBTSxFQUFFUCxJQUFLO2dCQUN0RCxNQUFNcUUsb0JBQW9CdEMsU0FBU3BELGVBQWUsQ0FBQ1UsS0FBSyxDQUFDVyxFQUFFO2dCQUMzRCxNQUFNc0UsVUFBVSxJQUFJRCxrQkFBa0J0RCxLQUFLLENBQUNDLFdBQVcsQ0FBQ2lDLGdCQUFnQixDQUFDNUQsS0FBSyxDQUFDVyxFQUFFO2dCQUNqRixNQUFNdUUsaUJBQWlCLElBQUloSCxrREFBZUEsQ0FBQytHLFNBQVNELGtCQUFrQjFELFFBQVEsRUFBRTBELGtCQUFrQnpELFVBQVU7Z0JBQzVHcUQsT0FBT3RGLGVBQWUsQ0FBQ1UsS0FBSyxDQUFDVyxFQUFFLEdBQUd1RTtZQUNwQztRQUNGO0lBQ0Y7SUFDQU4sT0FBTy9ELFFBQVEsQ0FBQ2dEO0lBQ2hCLE9BQU9lO0FBQ1Q7QUFDQSxTQUFTTyxvQkFBb0J6QyxRQUFRLEVBQUUwQyxRQUFRO0lBQzdDLElBQUlBLGFBQWEvRyxvREFBaUJBLEVBQUU7UUFDbEN5QixRQUFRdUYsSUFBSSxDQUFDO1FBQ2IsT0FBTzNDO0lBQ1Q7SUFDQSxJQUFJMEMsYUFBYTlHLHNEQUFtQkEsSUFBSThHLGFBQWE3Ryx3REFBcUJBLEVBQUU7UUFDMUUsSUFBSVEsUUFBUTJELFNBQVNLLFFBQVE7UUFDN0IsSUFBSWhFLFVBQVUsTUFBTTtZQUNsQixNQUFNK0QsVUFBVSxFQUFFO1lBQ2xCLE1BQU12QyxXQUFXbUMsU0FBU0UsWUFBWSxDQUFDO1lBQ3ZDLElBQUlyQyxhQUFhLEtBQUssR0FBRztnQkFDdkIsSUFBSyxJQUFJWCxJQUFJLEdBQUdBLElBQUlXLFNBQVNELEtBQUssRUFBRVYsSUFBSztvQkFDdkNrRCxRQUFRNUMsSUFBSSxDQUFDTjtnQkFDZjtnQkFDQThDLFNBQVM3QixRQUFRLENBQUNpQztnQkFDbEIvRCxRQUFRMkQsU0FBU0ssUUFBUTtZQUMzQixPQUFPO2dCQUNMakQsUUFBUUMsS0FBSyxDQUNYO2dCQUVGLE9BQU8yQztZQUNUO1FBQ0Y7UUFDQSxNQUFNNEMsb0JBQW9CdkcsTUFBTXVCLEtBQUssR0FBRztRQUN4QyxNQUFNdUQsYUFBYSxFQUFFO1FBQ3JCLElBQUk5RSxPQUFPO1lBQ1QsSUFBSXFHLGFBQWE5RyxzREFBbUJBLEVBQUU7Z0JBQ3BDLElBQUssSUFBSXNCLElBQUksR0FBR0EsS0FBSzBGLG1CQUFtQjFGLElBQUs7b0JBQzNDaUUsV0FBVzNELElBQUksQ0FBQ25CLE1BQU02QixJQUFJLENBQUM7b0JBQzNCaUQsV0FBVzNELElBQUksQ0FBQ25CLE1BQU02QixJQUFJLENBQUNoQjtvQkFDM0JpRSxXQUFXM0QsSUFBSSxDQUFDbkIsTUFBTTZCLElBQUksQ0FBQ2hCLElBQUk7Z0JBQ2pDO1lBQ0YsT0FBTztnQkFDTCxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSTBGLG1CQUFtQjFGLElBQUs7b0JBQzFDLElBQUlBLElBQUksTUFBTSxHQUFHO3dCQUNmaUUsV0FBVzNELElBQUksQ0FBQ25CLE1BQU02QixJQUFJLENBQUNoQjt3QkFDM0JpRSxXQUFXM0QsSUFBSSxDQUFDbkIsTUFBTTZCLElBQUksQ0FBQ2hCLElBQUk7d0JBQy9CaUUsV0FBVzNELElBQUksQ0FBQ25CLE1BQU02QixJQUFJLENBQUNoQixJQUFJO29CQUNqQyxPQUFPO3dCQUNMaUUsV0FBVzNELElBQUksQ0FBQ25CLE1BQU02QixJQUFJLENBQUNoQixJQUFJO3dCQUMvQmlFLFdBQVczRCxJQUFJLENBQUNuQixNQUFNNkIsSUFBSSxDQUFDaEIsSUFBSTt3QkFDL0JpRSxXQUFXM0QsSUFBSSxDQUFDbkIsTUFBTTZCLElBQUksQ0FBQ2hCO29CQUM3QjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJaUUsV0FBVzNDLE1BQU0sR0FBRyxNQUFNb0UsbUJBQW1CO1lBQy9DeEYsUUFBUUMsS0FBSyxDQUFDO1FBQ2hCO1FBQ0EsTUFBTXdGLGNBQWM3QyxTQUFTbUMsS0FBSztRQUNsQ1UsWUFBWTFFLFFBQVEsQ0FBQ2dEO1FBQ3JCMEIsWUFBWUMsV0FBVztRQUN2QixPQUFPRDtJQUNULE9BQU87UUFDTHpGLFFBQVFDLEtBQUssQ0FBQyx1RUFBdUVxRjtRQUNyRixPQUFPMUM7SUFDVDtBQUNGO0FBQ0EsU0FBUytDLHlCQUF5QkMsTUFBTTtJQUN0QyxJQUFJQSxPQUFPaEQsUUFBUSxDQUFDaUQsZ0JBQWdCLEtBQUssTUFBTTtRQUM3QzdGLFFBQVFDLEtBQUssQ0FBQztRQUNkLE9BQU87SUFDVDtJQUNBLE1BQU02RixNQUFNLElBQUlwSCwwQ0FBT0E7SUFDdkIsTUFBTXFILE1BQU0sSUFBSXJILDBDQUFPQTtJQUN2QixNQUFNc0gsTUFBTSxJQUFJdEgsMENBQU9BO0lBQ3ZCLE1BQU11SCxTQUFTLElBQUl2SCwwQ0FBT0E7SUFDMUIsTUFBTXdILFNBQVMsSUFBSXhILDBDQUFPQTtJQUMxQixNQUFNeUgsU0FBUyxJQUFJekgsMENBQU9BO0lBQzFCLE1BQU0wSCxVQUFVLElBQUkxSCwwQ0FBT0E7SUFDM0IsTUFBTTJILFVBQVUsSUFBSTNILDBDQUFPQTtJQUMzQixNQUFNNEgsVUFBVSxJQUFJNUgsMENBQU9BO0lBQzNCLFNBQVM2SCwrQkFBK0JDLE9BQU8sRUFBRUMsU0FBUyxFQUFFdkUsU0FBUyxFQUFFa0QsY0FBYyxFQUFFc0IscUJBQXFCLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLHNCQUFzQjtRQUM5SWhCLElBQUlpQixtQkFBbUIsQ0FBQzdFLFdBQVd5RTtRQUNuQ1osSUFBSWdCLG1CQUFtQixDQUFDN0UsV0FBVzBFO1FBQ25DWixJQUFJZSxtQkFBbUIsQ0FBQzdFLFdBQVcyRTtRQUNuQyxNQUFNRyxrQkFBa0JSLFFBQVFTLHFCQUFxQjtRQUNyRCxJQUNFLGFBQWE7UUFDYlIsVUFBVVMsWUFBWSxJQUFJOUIsa0JBQWtCNEIsaUJBQzVDO1lBQ0FaLFFBQVF0RSxHQUFHLENBQUMsR0FBRyxHQUFHO1lBQ2xCdUUsUUFBUXZFLEdBQUcsQ0FBQyxHQUFHLEdBQUc7WUFDbEJ3RSxRQUFReEUsR0FBRyxDQUFDLEdBQUcsR0FBRztZQUNsQixJQUFLLElBQUlxRixLQUFLLEdBQUdDLE1BQU1oQyxlQUFlaEUsTUFBTSxFQUFFK0YsS0FBS0MsS0FBS0QsS0FBTTtnQkFDNUQsTUFBTUUsWUFBWUwsZUFBZSxDQUFDRyxHQUFHO2dCQUNyQyxNQUFNRyxRQUFRbEMsY0FBYyxDQUFDK0IsR0FBRztnQkFDaEMsSUFBSUUsY0FBYyxHQUNoQjtnQkFDRnBCLE9BQU9jLG1CQUFtQixDQUFDTyxPQUFPWDtnQkFDbENULE9BQU9hLG1CQUFtQixDQUFDTyxPQUFPVjtnQkFDbENULE9BQU9ZLG1CQUFtQixDQUFDTyxPQUFPVDtnQkFDbEMsSUFBSUgsdUJBQXVCO29CQUN6Qk4sUUFBUW1CLGVBQWUsQ0FBQ3RCLFFBQVFvQjtvQkFDaENoQixRQUFRa0IsZUFBZSxDQUFDckIsUUFBUW1CO29CQUNoQ2YsUUFBUWlCLGVBQWUsQ0FBQ3BCLFFBQVFrQjtnQkFDbEMsT0FBTztvQkFDTGpCLFFBQVFtQixlQUFlLENBQUN0QixPQUFPdUIsR0FBRyxDQUFDMUIsTUFBTXVCO29CQUN6Q2hCLFFBQVFrQixlQUFlLENBQUNyQixPQUFPc0IsR0FBRyxDQUFDekIsTUFBTXNCO29CQUN6Q2YsUUFBUWlCLGVBQWUsQ0FBQ3BCLE9BQU9xQixHQUFHLENBQUN4QixNQUFNcUI7Z0JBQzNDO1lBQ0Y7WUFDQXZCLElBQUkyQixHQUFHLENBQUNyQjtZQUNSTCxJQUFJMEIsR0FBRyxDQUFDcEI7WUFDUkwsSUFBSXlCLEdBQUcsQ0FBQ25CO1FBQ1Y7UUFDQSxJQUFJRSxRQUFRa0IsYUFBYSxFQUFFO1lBQ3pCbEIsUUFBUW1CLGFBQWEsQ0FBQ2hCLElBQUliO1lBQzFCVSxRQUFRbUIsYUFBYSxDQUFDZixJQUFJYjtZQUMxQlMsUUFBUW1CLGFBQWEsQ0FBQ2QsSUFBSWI7UUFDNUI7UUFDQWMsc0JBQXNCLENBQUNILEtBQUssSUFBSSxFQUFFLEdBQUdiLElBQUk4QixDQUFDO1FBQzFDZCxzQkFBc0IsQ0FBQ0gsS0FBSyxJQUFJLEVBQUUsR0FBR2IsSUFBSStCLENBQUM7UUFDMUNmLHNCQUFzQixDQUFDSCxLQUFLLElBQUksRUFBRSxHQUFHYixJQUFJZ0MsQ0FBQztRQUMxQ2hCLHNCQUFzQixDQUFDRixLQUFLLElBQUksRUFBRSxHQUFHYixJQUFJNkIsQ0FBQztRQUMxQ2Qsc0JBQXNCLENBQUNGLEtBQUssSUFBSSxFQUFFLEdBQUdiLElBQUk4QixDQUFDO1FBQzFDZixzQkFBc0IsQ0FBQ0YsS0FBSyxJQUFJLEVBQUUsR0FBR2IsSUFBSStCLENBQUM7UUFDMUNoQixzQkFBc0IsQ0FBQ0QsS0FBSyxJQUFJLEVBQUUsR0FBR2IsSUFBSTRCLENBQUM7UUFDMUNkLHNCQUFzQixDQUFDRCxLQUFLLElBQUksRUFBRSxHQUFHYixJQUFJNkIsQ0FBQztRQUMxQ2Ysc0JBQXNCLENBQUNELEtBQUssSUFBSSxFQUFFLEdBQUdiLElBQUk4QixDQUFDO0lBQzVDO0lBQ0EsTUFBTWxGLFdBQVdnRCxPQUFPaEQsUUFBUTtJQUNoQyxNQUFNbUYsV0FBV25DLE9BQU9tQyxRQUFRO0lBQ2hDLElBQUlDLEdBQUdDLEdBQUd6RjtJQUNWLE1BQU12RCxRQUFRMkQsU0FBUzNELEtBQUs7SUFDNUIsTUFBTWlKLG9CQUFvQnRGLFNBQVN0RCxVQUFVLENBQUNtQixRQUFRO0lBQ3RELE1BQU0wSCxnQkFBZ0J2RixTQUFTcEQsZUFBZSxDQUFDaUIsUUFBUTtJQUN2RCxNQUFNaEIsdUJBQXVCbUQsU0FBU25ELG9CQUFvQjtJQUMxRCxNQUFNMkksa0JBQWtCeEYsU0FBU3RELFVBQVUsQ0FBQytJLE1BQU07SUFDbEQsTUFBTUMsY0FBYzFGLFNBQVNwRCxlQUFlLENBQUNpQixRQUFRO0lBQ3JELE1BQU04SCxTQUFTM0YsU0FBUzJGLE1BQU07SUFDOUIsTUFBTUMsWUFBWTVGLFNBQVM0RixTQUFTO0lBQ3BDLElBQUkxSSxHQUFHZSxHQUFHNEgsSUFBSUM7SUFDZCxJQUFJQyxPQUFPQztJQUNYLElBQUlDLE9BQU9DO0lBQ1gsTUFBTUMsbUJBQW1CLElBQUlDLGFBQWFkLGtCQUFrQjFILEtBQUssR0FBRzBILGtCQUFrQjFHLFFBQVE7SUFDOUYsTUFBTXlILGlCQUFpQixJQUFJRCxhQUFhWixnQkFBZ0I1SCxLQUFLLEdBQUc0SCxnQkFBZ0I1RyxRQUFRO0lBQ3hGLElBQUl2QyxVQUFVLE1BQU07UUFDbEIsSUFBSWdGLE1BQU1pRixPQUFPLENBQUNuQixXQUFXO1lBQzNCLElBQUtqSSxJQUFJLEdBQUcySSxLQUFLRixPQUFPbkgsTUFBTSxFQUFFdEIsSUFBSTJJLElBQUkzSSxJQUFLO2dCQUMzQzZJLFFBQVFKLE1BQU0sQ0FBQ3pJLEVBQUU7Z0JBQ2pCOEksZ0JBQWdCYixRQUFRLENBQUNZLE1BQU1RLGFBQWEsQ0FBQztnQkFDN0NOLFFBQVF6RixLQUFLQyxHQUFHLENBQUNzRixNQUFNRSxLQUFLLEVBQUVMLFVBQVVLLEtBQUs7Z0JBQzdDQyxNQUFNMUYsS0FBS2dHLEdBQUcsQ0FBQ1QsTUFBTUUsS0FBSyxHQUFHRixNQUFNbkksS0FBSyxFQUFFZ0ksVUFBVUssS0FBSyxHQUFHTCxVQUFVaEksS0FBSztnQkFDM0UsSUFBS0ssSUFBSWdJLE9BQU9ILEtBQUtJLEtBQUtqSSxJQUFJNkgsSUFBSTdILEtBQUssRUFBRztvQkFDeENtSCxJQUFJL0ksTUFBTTZCLElBQUksQ0FBQ0Q7b0JBQ2ZvSCxJQUFJaEosTUFBTTZCLElBQUksQ0FBQ0QsSUFBSTtvQkFDbkIyQixJQUFJdkQsTUFBTTZCLElBQUksQ0FBQ0QsSUFBSTtvQkFDbkIwRiwrQkFDRVgsUUFDQWdELGVBQ0FWLG1CQUNBQyxlQUNBMUksc0JBQ0F1SSxHQUNBQyxHQUNBekYsR0FDQXVHO29CQUVGeEMsK0JBQ0VYLFFBQ0FnRCxlQUNBUixpQkFDQUUsYUFDQTdJLHNCQUNBdUksR0FDQUMsR0FDQXpGLEdBQ0F5RztnQkFFSjtZQUNGO1FBQ0YsT0FBTztZQUNMSixRQUFRekYsS0FBS0MsR0FBRyxDQUFDLEdBQUdtRixVQUFVSyxLQUFLO1lBQ25DQyxNQUFNMUYsS0FBS2dHLEdBQUcsQ0FBQ25LLE1BQU11QixLQUFLLEVBQUVnSSxVQUFVSyxLQUFLLEdBQUdMLFVBQVVoSSxLQUFLO1lBQzdELElBQUtWLElBQUkrSSxPQUFPSixLQUFLSyxLQUFLaEosSUFBSTJJLElBQUkzSSxLQUFLLEVBQUc7Z0JBQ3hDa0ksSUFBSS9JLE1BQU02QixJQUFJLENBQUNoQjtnQkFDZm1JLElBQUloSixNQUFNNkIsSUFBSSxDQUFDaEIsSUFBSTtnQkFDbkIwQyxJQUFJdkQsTUFBTTZCLElBQUksQ0FBQ2hCLElBQUk7Z0JBQ25CeUcsK0JBQ0VYLFFBQ0FtQyxVQUNBRyxtQkFDQUMsZUFDQTFJLHNCQUNBdUksR0FDQUMsR0FDQXpGLEdBQ0F1RztnQkFFRnhDLCtCQUNFWCxRQUNBbUMsVUFDQUssaUJBQ0FFLGFBQ0E3SSxzQkFDQXVJLEdBQ0FDLEdBQ0F6RixHQUNBeUc7WUFFSjtRQUNGO0lBQ0YsT0FBTyxJQUFJZixzQkFBc0IsS0FBSyxHQUFHO1FBQ3ZDLElBQUlqRSxNQUFNaUYsT0FBTyxDQUFDbkIsV0FBVztZQUMzQixJQUFLakksSUFBSSxHQUFHMkksS0FBS0YsT0FBT25ILE1BQU0sRUFBRXRCLElBQUkySSxJQUFJM0ksSUFBSztnQkFDM0M2SSxRQUFRSixNQUFNLENBQUN6SSxFQUFFO2dCQUNqQjhJLGdCQUFnQmIsUUFBUSxDQUFDWSxNQUFNUSxhQUFhLENBQUM7Z0JBQzdDTixRQUFRekYsS0FBS0MsR0FBRyxDQUFDc0YsTUFBTUUsS0FBSyxFQUFFTCxVQUFVSyxLQUFLO2dCQUM3Q0MsTUFBTTFGLEtBQUtnRyxHQUFHLENBQUNULE1BQU1FLEtBQUssR0FBR0YsTUFBTW5JLEtBQUssRUFBRWdJLFVBQVVLLEtBQUssR0FBR0wsVUFBVWhJLEtBQUs7Z0JBQzNFLElBQUtLLElBQUlnSSxPQUFPSCxLQUFLSSxLQUFLakksSUFBSTZILElBQUk3SCxLQUFLLEVBQUc7b0JBQ3hDbUgsSUFBSW5IO29CQUNKb0gsSUFBSXBILElBQUk7b0JBQ1IyQixJQUFJM0IsSUFBSTtvQkFDUjBGLCtCQUNFWCxRQUNBZ0QsZUFDQVYsbUJBQ0FDLGVBQ0ExSSxzQkFDQXVJLEdBQ0FDLEdBQ0F6RixHQUNBdUc7b0JBRUZ4QywrQkFDRVgsUUFDQWdELGVBQ0FSLGlCQUNBRSxhQUNBN0ksc0JBQ0F1SSxHQUNBQyxHQUNBekYsR0FDQXlHO2dCQUVKO1lBQ0Y7UUFDRixPQUFPO1lBQ0xKLFFBQVF6RixLQUFLQyxHQUFHLENBQUMsR0FBR21GLFVBQVVLLEtBQUs7WUFDbkNDLE1BQU0xRixLQUFLZ0csR0FBRyxDQUFDbEIsa0JBQWtCMUgsS0FBSyxFQUFFZ0ksVUFBVUssS0FBSyxHQUFHTCxVQUFVaEksS0FBSztZQUN6RSxJQUFLVixJQUFJK0ksT0FBT0osS0FBS0ssS0FBS2hKLElBQUkySSxJQUFJM0ksS0FBSyxFQUFHO2dCQUN4Q2tJLElBQUlsSTtnQkFDSm1JLElBQUluSSxJQUFJO2dCQUNSMEMsSUFBSTFDLElBQUk7Z0JBQ1J5RywrQkFDRVgsUUFDQW1DLFVBQ0FHLG1CQUNBQyxlQUNBMUksc0JBQ0F1SSxHQUNBQyxHQUNBekYsR0FDQXVHO2dCQUVGeEMsK0JBQ0VYLFFBQ0FtQyxVQUNBSyxpQkFDQUUsYUFDQTdJLHNCQUNBdUksR0FDQUMsR0FDQXpGLEdBQ0F5RztZQUVKO1FBQ0Y7SUFDRjtJQUNBLE1BQU1JLDJCQUEyQixJQUFJMUsseURBQXNCQSxDQUFDb0ssa0JBQWtCO0lBQzlFLE1BQU1PLHlCQUF5QixJQUFJM0sseURBQXNCQSxDQUFDc0ssZ0JBQWdCO0lBQzFFLE9BQU87UUFDTGY7UUFDQUU7UUFDQWlCO1FBQ0FDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLGlCQUFpQjNHLFFBQVEsRUFBRTRHLGNBQWNwRyxLQUFLcUcsRUFBRSxHQUFHLENBQUM7SUFDM0QsTUFBTUMsWUFBWXRHLEtBQUt1RyxHQUFHLENBQUNIO0lBQzNCLE1BQU1JLGlCQUFpQixDQUFDLElBQUksS0FBSSxJQUFLO0lBQ3JDLE1BQU1DLFFBQVE7UUFBQyxJQUFJbkwsMENBQU9BO1FBQUksSUFBSUEsMENBQU9BO1FBQUksSUFBSUEsMENBQU9BO0tBQUc7SUFDM0QsTUFBTW9MLFdBQVcsSUFBSXBMLDBDQUFPQTtJQUM1QixNQUFNcUwsV0FBVyxJQUFJckwsMENBQU9BO0lBQzVCLE1BQU1zTCxXQUFXLElBQUl0TCwwQ0FBT0E7SUFDNUIsTUFBTXVMLFlBQVksSUFBSXZMLDBDQUFPQTtJQUM3QixTQUFTd0wsV0FBV0MsQ0FBQztRQUNuQixNQUFNdkMsSUFBSSxDQUFDLENBQUV1QyxDQUFBQSxFQUFFdkMsQ0FBQyxHQUFHZ0MsY0FBYTtRQUNoQyxNQUFNL0IsSUFBSSxDQUFDLENBQUVzQyxDQUFBQSxFQUFFdEMsQ0FBQyxHQUFHK0IsY0FBYTtRQUNoQyxNQUFNOUIsSUFBSSxDQUFDLENBQUVxQyxDQUFBQSxFQUFFckMsQ0FBQyxHQUFHOEIsY0FBYTtRQUNoQyxPQUFPLENBQUMsRUFBRWhDLEVBQUUsQ0FBQyxFQUFFQyxFQUFFLENBQUMsRUFBRUMsRUFBRSxDQUFDO0lBQ3pCO0lBQ0EsTUFBTXNDLGlCQUFpQnhILFNBQVMzRCxLQUFLLEdBQUcyRCxTQUFTeUgsWUFBWSxLQUFLekg7SUFDbEUsTUFBTTBILFVBQVVGLGVBQWU5SyxVQUFVLENBQUNtQixRQUFRO0lBQ2xELE1BQU04SixZQUFZLENBQUM7SUFDbkIsSUFBSyxJQUFJekssSUFBSSxHQUFHbUMsSUFBSXFJLFFBQVE5SixLQUFLLEdBQUcsR0FBR1YsSUFBSW1DLEdBQUduQyxJQUFLO1FBQ2pELE1BQU0wSyxLQUFLLElBQUkxSztRQUNmLE1BQU1rSSxJQUFJNkIsS0FBSyxDQUFDLEVBQUUsQ0FBQzlDLG1CQUFtQixDQUFDdUQsU0FBU0UsS0FBSztRQUNyRCxNQUFNdkMsSUFBSTRCLEtBQUssQ0FBQyxFQUFFLENBQUM5QyxtQkFBbUIsQ0FBQ3VELFNBQVNFLEtBQUs7UUFDckQsTUFBTWhJLElBQUlxSCxLQUFLLENBQUMsRUFBRSxDQUFDOUMsbUJBQW1CLENBQUN1RCxTQUFTRSxLQUFLO1FBQ3JEVixTQUFTVyxVQUFVLENBQUNqSSxHQUFHeUY7UUFDdkI4QixTQUFTVSxVQUFVLENBQUN6QyxHQUFHQztRQUN2QixNQUFNSSxTQUFTLElBQUkzSiwwQ0FBT0EsR0FBR2dNLFlBQVksQ0FBQ1osVUFBVUMsVUFBVVksU0FBUztRQUN2RSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCLE1BQU1DLE9BQU9oQixLQUFLLENBQUNlLEVBQUU7WUFDckIsTUFBTXBHLE9BQU8wRixXQUFXVztZQUN4QixJQUFJLENBQUVyRyxDQUFBQSxRQUFRK0YsU0FBUSxHQUFJO2dCQUN4QkEsU0FBUyxDQUFDL0YsS0FBSyxHQUFHLEVBQUU7WUFDdEI7WUFDQStGLFNBQVMsQ0FBQy9GLEtBQUssQ0FBQ3BFLElBQUksQ0FBQ2lJO1FBQ3ZCO0lBQ0Y7SUFDQSxNQUFNeUMsY0FBYyxJQUFJOUIsYUFBYXNCLFFBQVE5SixLQUFLLEdBQUc7SUFDckQsTUFBTXVLLFdBQVcsSUFBSTNNLGtEQUFlQSxDQUFDME0sYUFBYSxHQUFHO0lBQ3JELElBQUssSUFBSWhMLElBQUksR0FBR21DLElBQUlxSSxRQUFROUosS0FBSyxHQUFHLEdBQUdWLElBQUltQyxHQUFHbkMsSUFBSztRQUNqRCxNQUFNMEssS0FBSyxJQUFJMUs7UUFDZixNQUFNa0ksSUFBSTZCLEtBQUssQ0FBQyxFQUFFLENBQUM5QyxtQkFBbUIsQ0FBQ3VELFNBQVNFLEtBQUs7UUFDckQsTUFBTXZDLElBQUk0QixLQUFLLENBQUMsRUFBRSxDQUFDOUMsbUJBQW1CLENBQUN1RCxTQUFTRSxLQUFLO1FBQ3JELE1BQU1oSSxJQUFJcUgsS0FBSyxDQUFDLEVBQUUsQ0FBQzlDLG1CQUFtQixDQUFDdUQsU0FBU0UsS0FBSztRQUNyRFYsU0FBU1csVUFBVSxDQUFDakksR0FBR3lGO1FBQ3ZCOEIsU0FBU1UsVUFBVSxDQUFDekMsR0FBR0M7UUFDdkIrQixTQUFTVSxZQUFZLENBQUNaLFVBQVVDLFVBQVVZLFNBQVM7UUFDbkQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztZQUMxQixNQUFNQyxPQUFPaEIsS0FBSyxDQUFDZSxFQUFFO1lBQ3JCLE1BQU1wRyxPQUFPMEYsV0FBV1c7WUFDeEIsTUFBTUcsZUFBZVQsU0FBUyxDQUFDL0YsS0FBSztZQUNwQ3lGLFVBQVVuSSxHQUFHLENBQUMsR0FBRyxHQUFHO1lBQ3BCLElBQUssSUFBSVcsSUFBSSxHQUFHd0ksS0FBS0QsYUFBYTVKLE1BQU0sRUFBRXFCLElBQUl3SSxJQUFJeEksSUFBSztnQkFDckQsTUFBTXlJLFlBQVlGLFlBQVksQ0FBQ3ZJLEVBQUU7Z0JBQ2pDLElBQUl1SCxTQUFTbUIsR0FBRyxDQUFDRCxhQUFheEIsV0FBVztvQkFDdkNPLFVBQVV4QyxHQUFHLENBQUN5RDtnQkFDaEI7WUFDRjtZQUNBakIsVUFBVVUsU0FBUztZQUNuQkksU0FBU0ssTUFBTSxDQUFDWixLQUFLSSxHQUFHWCxVQUFVckMsQ0FBQyxFQUFFcUMsVUFBVXBDLENBQUMsRUFBRW9DLFVBQVVuQyxDQUFDO1FBQy9EO0lBQ0Y7SUFDQXNDLGVBQWVsSixZQUFZLENBQUMsVUFBVTZKO0lBQ3RDLE9BQU9YO0FBQ1Q7QUFVRSxDQUNGLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzPzEyZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBUcmlhbmdsZXNEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBWZWN0b3IzLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBnZXRXaXRoS2V5IH0gZnJvbSBcIi4uL3R5cGVzL2hlbHBlcnMuanNcIjtcbmNvbnN0IG1lcmdlQnVmZmVyR2VvbWV0cmllcyA9IChnZW9tZXRyaWVzLCB1c2VHcm91cHMpID0+IHtcbiAgY29uc3QgaXNJbmRleGVkID0gZ2VvbWV0cmllc1swXS5pbmRleCAhPT0gbnVsbDtcbiAgY29uc3QgYXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0uYXR0cmlidXRlcykpO1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLm1vcnBoQXR0cmlidXRlcykpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJpZXNbMF0ubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG1lcmdlZEdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20sIGkpID0+IHtcbiAgICBsZXQgYXR0cmlidXRlc0NvdW50ID0gMDtcbiAgICBpZiAoaXNJbmRleGVkICE9PSAoZ2VvbS5pbmRleCAhPT0gbnVsbCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgaW5kZXggYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArICcuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgIGF0dHJpYnV0ZXNDb3VudCsrO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlc0NvdW50ICE9PSBhdHRyaWJ1dGVzVXNlZC5zaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gTWFrZSBzdXJlIGFsbCBnZW9tZXRyaWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlICE9PSBnZW9tLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gLm1vcnBoVGFyZ2V0c1JlbGF0aXZlIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5tb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghbW9ycGhBdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gIC5tb3JwaEF0dHJpYnV0ZXMgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobW9ycGhBdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApXG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSA9IG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhIHx8IFtdO1xuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhLnB1c2goZ2VvbS51c2VyRGF0YSk7XG4gICAgaWYgKHVzZUdyb3Vwcykge1xuICAgICAgbGV0IGNvdW50O1xuICAgICAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmluZGV4LmNvdW50O1xuICAgICAgfSBlbHNlIGlmIChnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBjb3VudCA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIFRoZSBnZW9tZXRyeSBtdXN0IGhhdmUgZWl0aGVyIGFuIGluZGV4IG9yIGEgcG9zaXRpb24gYXR0cmlidXRlXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5hZGRHcm91cChvZmZzZXQsIGNvdW50LCBpKTtcbiAgICAgIG9mZnNldCArPSBjb3VudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoaXNJbmRleGVkKSB7XG4gICAgbGV0IGluZGV4T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBtZXJnZWRJbmRleCA9IFtdO1xuICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBnZW9tLmluZGV4O1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgKytqKSB7XG4gICAgICAgIG1lcmdlZEluZGV4LnB1c2goaW5kZXguZ2V0WChqKSArIGluZGV4T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGluZGV4T2Zmc2V0ICs9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICB9KTtcbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRJbmRleChtZXJnZWRJbmRleCk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIGlmICghbWVyZ2VkQXR0cmlidXRlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBhdHRyaWJ1dGUuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG1lcmdlZEF0dHJpYnV0ZSk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bMF0ubGVuZ3RoO1xuICAgIGlmIChudW1Nb3JwaFRhcmdldHMgPT09IDApXG4gICAgICBicmVhaztcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgPSBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgfHwge307XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7ICsraSkge1xuICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZS5wdXNoKG1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXVtpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWRNb3JwaEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhtb3JwaEF0dHJpYnV0ZXNUb01lcmdlKTtcbiAgICAgIGlmICghbWVyZ2VkTW9ycGhBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBtb3JwaEF0dHJpYnV0ZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKG1lcmdlZE1vcnBoQXR0cmlidXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZEdlb21ldHJ5O1xufTtcbmNvbnN0IG1lcmdlQnVmZmVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgaXRlbVNpemUgPSB2b2lkIDA7XG4gIGxldCBub3JtYWxpemVkID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKSB7XG4gICAgICBUeXBlZEFycmF5ID0gYXR0ci5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHIuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLmFycmF5IG11c3QgYmUgb2YgY29uc2lzdGVudCBhcnJheSB0eXBlcyBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXRlbVNpemUgPT09IHZvaWQgMClcbiAgICAgIGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcbiAgICBpZiAoaXRlbVNpemUgIT09IGF0dHIuaXRlbVNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLml0ZW1TaXplIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZCA9PT0gdm9pZCAwKVxuICAgICAgbm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcbiAgICBpZiAobm9ybWFsaXplZCAhPT0gYXR0ci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgfSk7XG4gIGlmIChUeXBlZEFycmF5ICYmIGl0ZW1TaXplKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBhcnJheS5zZXQoYXR0ci5hcnJheSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICB9XG59O1xuY29uc3QgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgbGV0IHN0cmlkZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApXG4gICAgICBUeXBlZEFycmF5ID0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdHRyaWJ1dGVCdWZmZXJzIG9mIGRpZmZlcmVudCB0eXBlcyBjYW5ub3QgYmUgaW50ZXJsZWF2ZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0cmlidXRlLmFycmF5Lmxlbmd0aDtcbiAgICBzdHJpZGUgKz0gYXR0cmlidXRlLml0ZW1TaXplO1xuICB9XG4gIGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKSwgc3RyaWRlKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgY29uc3Qgc2V0dGVycyA9IFtcInNldFhcIiwgXCJzZXRZXCIsIFwic2V0WlwiLCBcInNldFdcIl07XG4gIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgIGNvbnN0IGNvdW50ID0gYXR0cmlidXRlLmNvdW50O1xuICAgIGNvbnN0IGliYSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlcy5wdXNoKGliYSk7XG4gICAgb2Zmc2V0ICs9IGl0ZW1TaXplO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldFdpdGhLZXkoaWJhLCBzZXR0ZXJzW2tdKTtcbiAgICAgICAgY29uc3QgZ2V0ID0gZ2V0V2l0aEtleShhdHRyaWJ1dGUsIGdldHRlcnNba10pO1xuICAgICAgICBzZXQoYywgZ2V0KGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBlc3RpbWF0ZUJ5dGVzVXNlZChnZW9tZXRyeSkge1xuICBsZXQgbWVtID0gMDtcbiAgZm9yIChsZXQgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0ciA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBtZW0gKz0gYXR0ci5jb3VudCAqIGF0dHIuaXRlbVNpemUgKiBhdHRyLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBtZW0gKz0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgKiBpbmRpY2VzLml0ZW1TaXplICogaW5kaWNlcy5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDA7XG4gIHJldHVybiBtZW07XG59XG5mdW5jdGlvbiBtZXJnZVZlcnRpY2VzKGdlb21ldHJ5LCB0b2xlcmFuY2UgPSAxZS00KSB7XG4gIHRvbGVyYW5jZSA9IE1hdGgubWF4KHRvbGVyYW5jZSwgTnVtYmVyLkVQU0lMT04pO1xuICBjb25zdCBoYXNoVG9JbmRleCA9IHt9O1xuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gIGNvbnN0IHZlcnRleENvdW50ID0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgOiBwb3NpdGlvbnMuY291bnQ7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpO1xuICBjb25zdCBhdHRyQXJyYXlzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cnNBcnJheXMgPSB7fTtcbiAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgYXR0ckFycmF5c1tuYW1lXSA9IFtdO1xuICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICBtb3JwaEF0dHJzQXJyYXlzW25hbWVdID0gbmV3IEFycmF5KG1vcnBoQXR0ci5sZW5ndGgpLmZpbGwoMCkubWFwKCgpID0+IFtdKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFNoaWZ0ID0gTWF0aC5sb2cxMCgxIC8gdG9sZXJhbmNlKTtcbiAgY29uc3Qgc2hpZnRNdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWxTaGlmdCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IGluZGV4ID0gaW5kaWNlcyA/IGluZGljZXMuZ2V0WChpKSA6IGk7XG4gICAgbGV0IGhhc2ggPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBoYXNoICs9IGAke35+KGF0dHJpYnV0ZVtnZXR0ZXJzW2tdXShpbmRleCkgKiBzaGlmdE11bHRpcGxpZXIpfSxgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzaCBpbiBoYXNoVG9JbmRleCkge1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKGhhc2hUb0luZGV4W2hhc2hdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICAgIGNvbnN0IG5ld2FycmF5ID0gYXR0ckFycmF5c1tuYW1lXTtcbiAgICAgICAgY29uc3QgbmV3TW9ycGhBcnJheXMgPSBtb3JwaEF0dHJzQXJyYXlzW25hbWVdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBnZXR0ZXJGdW5jID0gZ2V0dGVyc1trXTtcbiAgICAgICAgICBuZXdhcnJheS5wdXNoKGF0dHJpYnV0ZVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0ci5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG4gICAgICAgICAgICAgIG5ld01vcnBoQXJyYXlzW21dLnB1c2gobW9ycGhBdHRyW21dW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYXNoVG9JbmRleFtoYXNoXSA9IG5leHRJbmRleDtcbiAgICAgIG5ld0luZGljZXMucHVzaChuZXh0SW5kZXgpO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGdlb21ldHJ5LmNsb25lKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgb2xkQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKGF0dHJBcnJheXNbbmFtZV0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyLCBvbGRBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXN1bHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSk7XG4gICAgaWYgKG5hbWUgaW4gbW9ycGhBdHRyc0FycmF5cykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJzQXJyYXlzW25hbWVdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG9sZE1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdO1xuICAgICAgICBjb25zdCBidWZmZXIyID0gbmV3IG9sZE1vcnBoQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKG1vcnBoQXR0cnNBcnJheXNbbmFtZV1bal0pO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyMiwgb2xkTW9ycGhBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZE1vcnBoQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgICAgICByZXN1bHQubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdID0gbW9ycGhBdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc3VsdC5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvVHJpYW5nbGVzRHJhd01vZGUoZ2VvbWV0cnksIGRyYXdNb2RlKSB7XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVzRHJhd01vZGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogR2VvbWV0cnkgYWxyZWFkeSBkZWZpbmVkIGFzIHRyaWFuZ2xlcy5cIik7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSB8fCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVTdHJpcERyYXdNb2RlKSB7XG4gICAgbGV0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgICBpZiAocG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmNvdW50OyBpKyspIHtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoaW5kaWNlcyk7XG4gICAgICAgIGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBudW1iZXJPZlRyaWFuZ2xlcyA9IGluZGV4LmNvdW50IC0gMjtcbiAgICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKDApKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdJbmRpY2VzLmxlbmd0aCAvIDMgIT09IG51bWJlck9mVHJpYW5nbGVzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdHZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgbmV3R2VvbWV0cnkuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gICAgbmV3R2VvbWV0cnkuY2xlYXJHcm91cHMoKTtcbiAgICByZXR1cm4gbmV3R2VvbWV0cnk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmtub3duIGRyYXcgbW9kZTpcIiwgZHJhd01vZGUpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzKG9iamVjdCkge1xuICBpZiAob2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgIT09IHRydWUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgQnVmZmVyR2VvbWV0cnkuXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IF92QSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShvYmplY3QyLCBtYXRlcmlhbDIsIGF0dHJpYnV0ZSwgbW9ycGhBdHRyaWJ1dGUsIG1vcnBoVGFyZ2V0c1JlbGF0aXZlMiwgYTIsIGIyLCBjMiwgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheSkge1xuICAgIF92QS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYTIpO1xuICAgIF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYjIpO1xuICAgIF92Qy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYzIpO1xuICAgIGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdDIubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuICAgIGlmIChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG1hdGVyaWFsMi5tb3JwaFRhcmdldHMgJiYgbW9ycGhBdHRyaWJ1dGUgJiYgbW9ycGhJbmZsdWVuY2VzXG4gICAgKSB7XG4gICAgICBfbW9ycGhBLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEIuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQy5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGlsMiA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaTIgPCBpbDI7IGkyKyspIHtcbiAgICAgICAgY29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzW2kyXTtcbiAgICAgICAgY29uc3QgbW9ycGggPSBtb3JwaEF0dHJpYnV0ZVtpMl07XG4gICAgICAgIGlmIChpbmZsdWVuY2UgPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIF90ZW1wQS5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBhMik7XG4gICAgICAgIF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBiMik7XG4gICAgICAgIF90ZW1wQy5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBjMik7XG4gICAgICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZTIpIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQywgaW5mbHVlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEuc3ViKF92QSksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLnN1YihfdkIpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQy5zdWIoX3ZDKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3ZBLmFkZChfbW9ycGhBKTtcbiAgICAgIF92Qi5hZGQoX21vcnBoQik7XG4gICAgICBfdkMuYWRkKF9tb3JwaEMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0Mi5pc1NraW5uZWRNZXNoKSB7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYTIsIF92QSk7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYjIsIF92Qik7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYzIsIF92Qyk7XG4gICAgfVxuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMF0gPSBfdkEueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDFdID0gX3ZBLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAyXSA9IF92QS56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMF0gPSBfdkIueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDFdID0gX3ZCLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAyXSA9IF92Qi56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMF0gPSBfdkMueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDFdID0gX3ZDLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAyXSA9IF92Qy56O1xuICB9XG4gIGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICBjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcbiAgbGV0IGEsIGIsIGM7XG4gIGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3Qgbm9ybWFsQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gIGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gIGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcbiAgbGV0IGksIGosIGlsLCBqbDtcbiAgbGV0IGdyb3VwLCBncm91cE1hdGVyaWFsO1xuICBsZXQgc3RhcnQsIGVuZDtcbiAgY29uc3QgbW9kaWZpZWRQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiBwb3NpdGlvbkF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGNvbnN0IG1vZGlmaWVkTm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxBdHRyaWJ1dGUuY291bnQgKiBub3JtYWxBdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBpbmRleC5nZXRYKGopO1xuICAgICAgICAgIGIgPSBpbmRleC5nZXRYKGogKyAxKTtcbiAgICAgICAgICBjID0gaW5kZXguZ2V0WChqICsgMik7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpbmRleC5nZXRYKGkpO1xuICAgICAgICBiID0gaW5kZXguZ2V0WChpICsgMSk7XG4gICAgICAgIGMgPSBpbmRleC5nZXRYKGkgKyAyKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocG9zaXRpb25BdHRyaWJ1dGUgIT09IHZvaWQgMCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGo7XG4gICAgICAgICAgYiA9IGogKyAxO1xuICAgICAgICAgIGMgPSBqICsgMjtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGk7XG4gICAgICAgIGIgPSBpICsgMTtcbiAgICAgICAgYyA9IGkgKyAyO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZFBvc2l0aW9uLCAzKTtcbiAgY29uc3QgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkTm9ybWFsLCAzKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG1vcnBoZWROb3JtYWxBdHRyaWJ1dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ3JlYXNlZE5vcm1hbHMoZ2VvbWV0cnksIGNyZWFzZUFuZ2xlID0gTWF0aC5QSSAvIDMpIHtcbiAgY29uc3QgY3JlYXNlRG90ID0gTWF0aC5jb3MoY3JlYXNlQW5nbGUpO1xuICBjb25zdCBoYXNoTXVsdGlwbGllciA9ICgxICsgMWUtMTApICogMTAwO1xuICBjb25zdCB2ZXJ0cyA9IFtuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpXTtcbiAgY29uc3QgdGVtcFZlYzEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wVmVjMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0yID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gaGFzaFZlcnRleCh2KSB7XG4gICAgY29uc3QgeCA9IH5+KHYueCAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB5ID0gfn4odi55ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHogPSB+fih2LnogKiBoYXNoTXVsdGlwbGllcik7XG4gICAgcmV0dXJuIGAke3h9LCR7eX0sJHt6fWA7XG4gIH1cbiAgY29uc3QgcmVzdWx0R2VvbWV0cnkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpIDogZ2VvbWV0cnk7XG4gIGNvbnN0IHBvc0F0dHIgPSByZXN1bHRHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgaWYgKCEoaGFzaCBpbiB2ZXJ0ZXhNYXApKSB7XG4gICAgICAgIHZlcnRleE1hcFtoYXNoXSA9IFtdO1xuICAgICAgfVxuICAgICAgdmVydGV4TWFwW2hhc2hdLnB1c2gobm9ybWFsKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc0F0dHIuY291bnQgKiAzKTtcbiAgY29uc3Qgbm9ybUF0dHIgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5vcm1hbEFycmF5LCAzLCBmYWxzZSk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICB0ZW1wTm9ybS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBjb25zdCBvdGhlck5vcm1hbHMgPSB2ZXJ0ZXhNYXBbaGFzaF07XG4gICAgICB0ZW1wTm9ybTIuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgayA9IDAsIGxrID0gb3RoZXJOb3JtYWxzLmxlbmd0aDsgayA8IGxrOyBrKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXJOb3JtID0gb3RoZXJOb3JtYWxzW2tdO1xuICAgICAgICBpZiAodGVtcE5vcm0uZG90KG90aGVyTm9ybSkgPiBjcmVhc2VEb3QpIHtcbiAgICAgICAgICB0ZW1wTm9ybTIuYWRkKG90aGVyTm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBOb3JtMi5ub3JtYWxpemUoKTtcbiAgICAgIG5vcm1BdHRyLnNldFhZWihpMyArIG4sIHRlbXBOb3JtMi54LCB0ZW1wTm9ybTIueSwgdGVtcE5vcm0yLnopO1xuICAgIH1cbiAgfVxuICByZXN1bHRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbm9ybUF0dHIpO1xuICByZXR1cm4gcmVzdWx0R2VvbWV0cnk7XG59XG5leHBvcnQge1xuICBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMsXG4gIGVzdGltYXRlQnl0ZXNVc2VkLFxuICBpbnRlcmxlYXZlQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckdlb21ldHJpZXMsXG4gIG1lcmdlVmVydGljZXMsXG4gIHRvQ3JlYXNlZE5vcm1hbHMsXG4gIHRvVHJpYW5nbGVzRHJhd01vZGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJHZW9tZXRyeVV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkJ1ZmZlckdlb21ldHJ5IiwiQnVmZmVyQXR0cmlidXRlIiwiSW50ZXJsZWF2ZWRCdWZmZXIiLCJJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSIsIlRyaWFuZ2xlc0RyYXdNb2RlIiwiVHJpYW5nbGVGYW5EcmF3TW9kZSIsIlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSIsIlZlY3RvcjMiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwiZ2V0V2l0aEtleSIsIm1lcmdlQnVmZmVyR2VvbWV0cmllcyIsImdlb21ldHJpZXMiLCJ1c2VHcm91cHMiLCJpc0luZGV4ZWQiLCJpbmRleCIsImF0dHJpYnV0ZXNVc2VkIiwiU2V0IiwiT2JqZWN0Iiwia2V5cyIsImF0dHJpYnV0ZXMiLCJtb3JwaEF0dHJpYnV0ZXNVc2VkIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJtZXJnZWRHZW9tZXRyeSIsIm9mZnNldCIsImZvckVhY2giLCJnZW9tIiwiaSIsImF0dHJpYnV0ZXNDb3VudCIsImNvbnNvbGUiLCJlcnJvciIsIm5hbWUiLCJoYXMiLCJwdXNoIiwic2l6ZSIsInVzZXJEYXRhIiwibWVyZ2VkVXNlckRhdGEiLCJjb3VudCIsInBvc2l0aW9uIiwiYWRkR3JvdXAiLCJpbmRleE9mZnNldCIsIm1lcmdlZEluZGV4IiwiaiIsImdldFgiLCJzZXRJbmRleCIsIm1lcmdlZEF0dHJpYnV0ZSIsIm1lcmdlQnVmZmVyQXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsIm51bU1vcnBoVGFyZ2V0cyIsImxlbmd0aCIsIm1vcnBoQXR0cmlidXRlc1RvTWVyZ2UiLCJtZXJnZWRNb3JwaEF0dHJpYnV0ZSIsIlR5cGVkQXJyYXkiLCJpdGVtU2l6ZSIsIm5vcm1hbGl6ZWQiLCJhcnJheUxlbmd0aCIsImF0dHIiLCJhcnJheSIsImNvbnN0cnVjdG9yIiwic2V0IiwiaW50ZXJsZWF2ZUF0dHJpYnV0ZXMiLCJzdHJpZGUiLCJsIiwiYXR0cmlidXRlIiwiaW50ZXJsZWF2ZWRCdWZmZXIiLCJyZXMiLCJnZXR0ZXJzIiwic2V0dGVycyIsImliYSIsImMiLCJrIiwiZ2V0IiwiZXN0aW1hdGVCeXRlc1VzZWQiLCJnZW9tZXRyeSIsIm1lbSIsImdldEF0dHJpYnV0ZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiaW5kaWNlcyIsImdldEluZGV4IiwibWVyZ2VWZXJ0aWNlcyIsInRvbGVyYW5jZSIsIk1hdGgiLCJtYXgiLCJOdW1iZXIiLCJFUFNJTE9OIiwiaGFzaFRvSW5kZXgiLCJwb3NpdGlvbnMiLCJ2ZXJ0ZXhDb3VudCIsIm5leHRJbmRleCIsImF0dHJpYnV0ZU5hbWVzIiwiYXR0ckFycmF5cyIsIm1vcnBoQXR0cnNBcnJheXMiLCJuZXdJbmRpY2VzIiwibW9ycGhBdHRyIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiZGVjaW1hbFNoaWZ0IiwibG9nMTAiLCJzaGlmdE11bHRpcGxpZXIiLCJwb3ciLCJoYXNoIiwibmV3YXJyYXkiLCJuZXdNb3JwaEFycmF5cyIsImdldHRlckZ1bmMiLCJtIiwibWwiLCJyZXN1bHQiLCJjbG9uZSIsIm9sZEF0dHJpYnV0ZSIsImJ1ZmZlciIsIm9sZE1vcnBoQXR0cmlidXRlIiwiYnVmZmVyMiIsIm1vcnBoQXR0cmlidXRlIiwidG9UcmlhbmdsZXNEcmF3TW9kZSIsImRyYXdNb2RlIiwid2FybiIsIm51bWJlck9mVHJpYW5nbGVzIiwibmV3R2VvbWV0cnkiLCJjbGVhckdyb3VwcyIsImNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyIsIm9iamVjdCIsImlzQnVmZmVyR2VvbWV0cnkiLCJfdkEiLCJfdkIiLCJfdkMiLCJfdGVtcEEiLCJfdGVtcEIiLCJfdGVtcEMiLCJfbW9ycGhBIiwiX21vcnBoQiIsIl9tb3JwaEMiLCJfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEiLCJvYmplY3QyIiwibWF0ZXJpYWwyIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUyIiwiYTIiLCJiMiIsImMyIiwibW9kaWZpZWRBdHRyaWJ1dGVBcnJheSIsImZyb21CdWZmZXJBdHRyaWJ1dGUiLCJtb3JwaEluZmx1ZW5jZXMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJtb3JwaFRhcmdldHMiLCJpMiIsImlsMiIsImluZmx1ZW5jZSIsIm1vcnBoIiwiYWRkU2NhbGVkVmVjdG9yIiwic3ViIiwiYWRkIiwiaXNTa2lubmVkTWVzaCIsImJvbmVUcmFuc2Zvcm0iLCJ4IiwieSIsInoiLCJtYXRlcmlhbCIsImEiLCJiIiwicG9zaXRpb25BdHRyaWJ1dGUiLCJtb3JwaFBvc2l0aW9uIiwibm9ybWFsQXR0cmlidXRlIiwibm9ybWFsIiwibW9ycGhOb3JtYWwiLCJncm91cHMiLCJkcmF3UmFuZ2UiLCJpbCIsImpsIiwiZ3JvdXAiLCJncm91cE1hdGVyaWFsIiwic3RhcnQiLCJlbmQiLCJtb2RpZmllZFBvc2l0aW9uIiwiRmxvYXQzMkFycmF5IiwibW9kaWZpZWROb3JtYWwiLCJpc0FycmF5IiwibWF0ZXJpYWxJbmRleCIsIm1pbiIsIm1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSIsIm1vcnBoZWROb3JtYWxBdHRyaWJ1dGUiLCJ0b0NyZWFzZWROb3JtYWxzIiwiY3JlYXNlQW5nbGUiLCJQSSIsImNyZWFzZURvdCIsImNvcyIsImhhc2hNdWx0aXBsaWVyIiwidmVydHMiLCJ0ZW1wVmVjMSIsInRlbXBWZWMyIiwidGVtcE5vcm0iLCJ0ZW1wTm9ybTIiLCJoYXNoVmVydGV4IiwidiIsInJlc3VsdEdlb21ldHJ5IiwidG9Ob25JbmRleGVkIiwicG9zQXR0ciIsInZlcnRleE1hcCIsImkzIiwic3ViVmVjdG9ycyIsImNyb3NzVmVjdG9ycyIsIm5vcm1hbGl6ZSIsIm4iLCJ2ZXJ0Iiwibm9ybWFsQXJyYXkiLCJub3JtQXR0ciIsIm90aGVyTm9ybWFscyIsImxrIiwib3RoZXJOb3JtIiwiZG90Iiwic2V0WFlaIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;